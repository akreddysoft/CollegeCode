Microsoft (R) Macro Assembler Version 6.14.8444		    10/02/03 01:36:52
E:\PROGRA~1\WIN32ASM\editkg.asm				     Page 1 - 1


				;EDITPLUS KEYGEN BY MADHUR
				.386                             
				.model	flat,stdcall             
				option 	casemap:none             
				.NOLIST
				;include e:\masm32\include\masm32.inc
				.LISTALL
				;includelib e:\masm32\lib\masm32.lib
				includelib e:\masm32\lib\user32.lib            
				includelib e:\masm32\lib\kernel32.lib          
 00000000			.data                            
 00000000 6D 61 64 68 75	name1	db	'madhur',20 dup(0)
	   72
	   00000014 [
	    00
	   ]
 0000001A 6D 61 64 66		regcode	db	'madf',20 dup(0)                                 
	   00000014 [
	    00
	   ]
 00000032  00000200 [		magical_value	db	200h dup(0)
	    00
	   ]
 00000232 34 35 34 35		serial		db	'4545',10 dup(0)
	   0000000A [
	    00
	   ]
 00000240  0000000A [		calval		db	10 dup(0)
	    00
	   ]
 00000000			.data?                           
 00000000 00000000		hinst	HINSTANCE	?
 00000000			.const
 00000000 44 49 41 4C 4F	dialog	db	'DIALOG_1',0
	   47 5F 31 00
 00000009 44 49 41 4C 4F	abtdlg	db	'DIALOG_2',0
	   47 5F 32 00
 00000012 43 68 65 63 6B	err1	db	'Check, something is missing',0
	   2C 20 73 6F 6D
	   65 74 68 69 6E
	   67 20 69 73 20
	   6D 69 73 73 69
	   6E 67 00
 0000002E 57 69 6E 7A 69	title1	db	'Winzip key generator by Madhur',0
	   70 20 6B 65 79
	   20 67 65 6E 65
	   72 61 74 6F 72
	   20 62 79 20 4D
	   61 64 68 75 72
	   00
 0000004D 65 6E 74 65 72	err2	db	'enter name',0
	   20 6E 61 6D 65
	   00
 = 00000065			IDCNAME	EQU	101
 = 00000066			IDCREG	EQU	102
 = 00000001			IDABOUT	EQU	1
 = 00000002			IDEXIT	EQU	2
 = 00000067			IDOK1	EQU	103                                 
 = 0000000A			IDCSTAT	EQU	10
				dlgproc	proto hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				abtdlgproc proto hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				dw2hex proto :dword,:dword
 00000000			.code                            
 00000000			start:                           
 00000000				invoke	GetModuleHandle,0
 00000000  6A 00	   *	    push   +000000000h
 00000002  E8 00000000 E   *	    call   GetModuleHandleA
 00000007  A3 00000000 R		mov	[hinst],eax
					invoke	DialogBoxParam,hinst,addr dialog,0,addr dlgproc,0
 0000000C  6A 00	   *	    push   +000000000h
 0000000E  68 0000002C R   *	    push   dlgproc
 00000013  6A 00	   *	    push   +000000000h
 00000015  68 00000000 R   *	    push   OFFSET dialog
 0000001A  FF 35 00000000 R *	    push   hinst
 00000020  E8 00000000 E   *	    call   DialogBoxParamA
					invoke	ExitProcess,0
 00000025  6A 00	   *	    push   +000000000h
 00000027  E8 00000000 E   *	    call   ExitProcess
					
 0000002C 0000002C		dlgproc	proc hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 0000002C  55		   *	    push   ebp
 0000002D  8B EC	   *	    mov    ebp, esp
					.if	uMsg==WM_INITDIALOG
 0000002F  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000036  75 28	   *	    jne    @C0001
						invoke	SetDlgItemText,hwnd,IDCNAME,addr name1
 00000038  68 00000000 R   *	    push   OFFSET name1
 0000003D  6A 65	   *	    push   +000000065h
 0000003F  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000042  E8 00000000 E   *	    call   SetDlgItemTextA
 00000047  E8 00000114			call	getit
						invoke	SetDlgItemText,hwnd,IDCREG,addr regcode	
 0000004C  68 0000001A R   *	    push   OFFSET regcode
 00000051  6A 66	   *	    push   +000000066h
 00000053  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000056  E8 00000000 E   *	    call   SetDlgItemTextA
					.elseif	uMsg==WM_COMMAND
 0000005B  E9 000000C4	   *	    jmp    @C0003
 00000060		   *@C0001:
 00000060  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 00000067  0F 85 000000AE  *	    jne    @C0004
 0000006D  8B 45 10				mov	eax,wparam
						.if	ax==IDCNAME                                 
 00000070  66| 83 F8 65	   *	    cmp    ax, IDCNAME
 00000074  75 71	   *	    jne    @C0006
 00000076  C1 E8 10					shr	eax,16
							.if	ax==EN_CHANGE
 00000079  66| 3D 0300	   *	    cmp    ax, EN_CHANGE
 0000007D  0F 85 000000A1  *	    jne    @C0008
								invoke	GetDlgItemText,hwnd,IDCNAME,addr name1,20
 00000083  6A 14	   *	    push   +000000014h
 00000085  68 00000000 R   *	    push   OFFSET name1
 0000008A  6A 65	   *	    push   +000000065h
 0000008C  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000008F  E8 00000000 E   *	    call   GetDlgItemTextA
								invoke	lstrlen,addr name1
 00000094  68 00000000 R   *	    push   OFFSET name1
 00000099  E8 00000000 E   *	    call   lstrlenA
								.if	eax==0
 0000009E  0B C0	   *	    or	eax, eax
 000000A0  75 20	   *	    jne    @C000A
									invoke	SetDlgItemText,hwnd,IDCREG,addr err2
 000000A2  68 0000004D R   *	    push   OFFSET err2
 000000A7  6A 66	   *	    push   +000000066h
 000000A9  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000000AC  E8 00000000 E   *	    call   SetDlgItemTextA
									invoke	SetDlgItemText,hwnd,IDCSTAT,addr err1
 000000B1  68 00000012 R   *	    push   OFFSET err1
 000000B6  6A 0A	   *	    push   +00000000Ah
 000000B8  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000000BB  E8 00000000 E   *	    call   SetDlgItemTextA
								.else					
 000000C0  EB 23	   *	    jmp    @C000C
 000000C2		   *@C000A:
 000000C2  E8 00000099							call	getit
									invoke	SetDlgItemText,hwnd,IDCREG,addr serial	
 000000C7  68 00000232 R   *	    push   OFFSET serial
 000000CC  6A 66	   *	    push   +000000066h
 000000CE  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000000D1  E8 00000000 E   *	    call   SetDlgItemTextA
									invoke	SetDlgItemText,hwnd,IDCSTAT,addr title1
 000000D6  68 0000002E R   *	    push   OFFSET title1
 000000DB  6A 0A	   *	    push   +00000000Ah
 000000DD  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000000E0  E8 00000000 E   *	    call   SetDlgItemTextA
								.endif
							.endif				
 000000E5		   *@C000C:
						.elseif	ax==IDABOUT
 000000E5  EB 3D	   *	    jmp    @C000D
 000000E7		   *@C0006:
 000000E7  66| 83 F8 01	   *	    cmp    ax, IDABOUT
 000000EB  75 1C	   *	    jne    @C000E
							invoke	DialogBoxParam,hinst,addr abtdlg,hwnd,addr abtdlgproc,0
 000000ED  6A 00	   *	    push   +000000000h
 000000EF  68 0000012D R   *	    push   abtdlgproc
 000000F4  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000000F7  68 00000009 R   *	    push   OFFSET abtdlg
 000000FC  FF 35 00000000 R *	    push   hinst
 00000102  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDEXIT
 00000107  EB 1B	   *	    jmp    @C0010
 00000109		   *@C000E:
 00000109  66| 83 F8 02	   *	    cmp    ax, IDEXIT
 0000010D  75 15	   *	    jne    @C0011
							invoke	EndDialog,hwnd,0
 0000010F  6A 00	   *	    push   +000000000h
 00000111  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000114  E8 00000000 E   *	    call   EndDialog
						.endif
					.else
 00000119  EB 09	   *	    jmp    @C0013
 0000011B		   *@C0004:
 0000011B  B8 00000000				mov	eax,FALSE
						ret
 00000120  C9		   *	    leave  
 00000121  C2 0010	   *	    ret    00010h
					.endif
 00000124		   *@C0013:
 00000124		   *@C0003:
 00000124		   *@C0011:
 00000124		   *@C0010:
 00000124		   *@C000D:
 00000124		   *@C0008:
 00000124  B8 00000001			mov	eax,TRUE
					ret
 00000129  C9		   *	    leave  
 0000012A  C2 0010	   *	    ret    00010h
 0000012D			dlgproc	endp			                                 

 0000012D			abtdlgproc	proc hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 0000012D  55		   *	    push   ebp
 0000012E  8B EC	   *	    mov    ebp, esp
					.if	uMsg==WM_COMMAND
 00000130  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 00000137  75 15	   *	    jne    @C0014
 00000139  8B 45 10				mov	eax,wparam
						.if	ax==IDOK1
 0000013C  66| 83 F8 67	   *	    cmp    ax, IDOK1
 00000140  75 15	   *	    jne    @C0016
							invoke	EndDialog,hwnd,0
 00000142  6A 00	   *	    push   +000000000h
 00000144  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000147  E8 00000000 E   *	    call   EndDialog
						.endif
					.else
 0000014C  EB 09	   *	    jmp    @C0018
 0000014E		   *@C0014:
 0000014E  B8 00000000				mov	eax,FALSE
						ret
 00000153  C9		   *	    leave  
 00000154  C2 0010	   *	    ret    00010h
					.endif
 00000157		   *@C0018:
 00000157		   *@C0016:
 00000157  B8 00000001			mov	eax,TRUE
					ret
 0000015C  C9		   *	    leave  
 0000015D  C2 0010	   *	    ret    00010h
 00000160			abtdlgproc	endp								
						                                 
 00000160			getit	proc	
 00000160  E8 0000007D			call	cal1
					invoke	lstrlen,offset name1
 00000165  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:name1
 0000016A  E8 00000000 E   *	    call   lstrlenA
 0000016F  8B F0			mov	esi,eax		
 00000171  BF 00000000 R		mov	edi,offset name1
					
 00000176  56				push	esi		;push 	length	
 00000177  57				push	edi		;push	name
 00000178  6A 00			push	0
 0000017A  E8 00000099			call	cal2		;get number
					
 0000017F  83 C4 0C			add     esp, 0Ch
 00000182  25 0000FFFF		        and     eax, 0FFFFh
 00000187  8B D8			mov	ebx,eax
					invoke	dw2hex,ebx,addr calval
 00000189  68 00000240 R   *	    push   OFFSET calval
 0000018E  53		   *	    push   ebx
 0000018F  E8 000000C5	   *	    call   dw2hex


 00000194  A0 00000240 R		mov	al,calval		;get their first char
 00000199  A2 00000234 R		mov	[serial+2],al		;move into out third

 0000019E  A0 00000241 R	        mov     al, [calval+1]		;get	their second char
 000001A3  A2 00000235 R		mov	[serial+3],al		;move into our 4hth pos

 000001A8  6A 02		        push    2
 000001AA  68 00000234 R	        push    offset [serial+2]			;push pointer to third char
 000001AF  6A 00		        push    0        
				       
 000001B1  E8 00000062		       	call	cal2
				       
 000001B6  83 C4 0C		        add     esp, 0Ch
 000001B9  25 0000FFFF		   	and     eax, 0FFFFh

 000001BE  8B D8			mov	ebx,eax
					invoke	dw2hex,ebx,addr calval
 000001C0  68 00000240 R   *	    push   OFFSET calval
 000001C5  53		   *	    push   ebx
 000001C6  E8 0000008E	   *	    call   dw2hex
					
 000001CB  A0 00000241 R		mov	al,[calval+1]
 000001D0  A2 00000233 R		mov	[serial+1],al   
 000001D5  8A 15 00000240 R		mov	dl,[calval]
 000001DB  88 15 00000232 R		mov	[serial],dl        
 000001E1  C3			        ret
 000001E2			getit	endp

				;##########################################################

				;##########################################################
 000001E2			cal1	proc
 000001E2  33 F6		        xor     esi, esi
 000001E4  BA 00000032 R	        mov     edx, offset magical_value

 000001E9			loc_0_46B617:
 000001E9  B8 0000C0C1			mov	eax,0c0c1h
 000001EE  B9 00000001			mov	ecx,1
 000001F3			loc_0_46B621:
 000001F3  85 F1		        test    esi, ecx
 000001F5  74 03		        jz      short loc_0_46B628
 000001F7  66| 31 02		        xor     [edx], ax
				      
 000001FA			loc_0_46B628:                                ; CODE XREF
 000001FA  03 C0		        add     eax, eax
 000001FC  D1 E1		        shl     ecx, 1
 000001FE  35 00004003		        xor     eax, 4003h
 00000203  81 F9 00000100	        cmp     ecx, 100h
 00000209  7C E8		        jl      short loc_0_46B621
 0000020B  83 C2 02		        add     edx, 2
 0000020E  46			        inc     esi
 0000020F  81 FA 00000232 R	        cmp     edx, offset magical_value+200h
 00000215  7C D2		        jl      short loc_0_46B617
 00000217  C3				ret
 00000218			cal1	endp
				;##########################################################

				;##########################################################
 00000218			cal2	proc

 = 00000004			zero	equ	4
 = 00000008			name2	equ	8
 = 0000000C			len	equ	0ch

 00000218  8B 4C 24 08		        mov     ecx, [esp+name2]
 0000021C  8B 44 24 0C		        mov     eax, [esp+len]
 00000220  56			        push    esi
 00000221  8D 34 08		        lea     esi, [ecx+eax]
 00000224  3B CE		        cmp     ecx, esi
 00000226  73 2A		        jnb     short loc_0_46B68A
 00000228  8B 44 24 08		        mov     eax, [esp+4+zero]
 0000022C  53			        push    ebx
 0000022D			loopcal:      
 0000022D  8B D0		        mov     edx, eax
 0000022F  33 DB		        xor     ebx, ebx
 00000231  8A 19		        mov     bl, [ecx]
 00000233  81 E2 000000FF	        and     edx, 0FFh
 00000239  33 D3		        xor     edx, ebx
 0000023B  33 DB		        xor     ebx, ebx
 0000023D  8A DC		        mov     bl, ah
 0000023F  66| 8B 04 55		        mov     ax, word ptr [magical_value+edx*2]
	   00000032 R
 00000247  66| 33 C3		        xor     ax, bx
 0000024A  41			        inc     ecx
 0000024B  3B CE		        cmp     ecx, esi
 0000024D  72 DE		        jb      short loopcal
 0000024F  5B			        pop     ebx
 00000250  5E			        pop     esi
 00000251  C3			        retn

 00000252			loc_0_46B68A:                           ; CODE XREF
 00000252  66| 8B 44 24		        mov     ax, word ptr [esp+4+zero]
	   08
 00000257  5E			        pop     esi
 00000258  C3			        retn
 00000259			cal2	endp  

 00000259			dw2hex	proc    wd:dword,adr:dword
 00000259  55		   *	    push   ebp
 0000025A  8B EC	   *	    mov    ebp, esp
 0000025C  50				push	eax
 0000025D  53				push	ebx
 0000025E  51				push	ecx
 0000025F  52				push	edx
 00000260  56				push	esi
 00000261  57				push	edi

 00000262  66| 33 DB			xor	bx,bx
 00000265  66| 33 FF			xor	di,di
 00000268  8B 75 0C			mov	esi,adr
 0000026B  8B 45 08			mov	eax,wd
 0000026E  B3 10			mov	bl,10h
 00000270			@@divide:
 00000270  33 D2			xor	edx,edx
 00000272  66| F7 F3			div	bx
 00000275  52				push	edx
 00000276  66| 47			inc	di
 00000278  66| 83 F8 00			cmp	ax,0
 0000027C  75 F2			jne	@@divide

 0000027E			@@store:
 0000027E  5A				pop	edx
 0000027F  66| 83 FA 09			cmp	dx,9
 00000283  77 06			ja	@@char
 00000285  66| 83 C2 30			add	dx,30h
 00000289  EB 04			jmp	@@cont
 0000028B			@@char:
 0000028B  66| 83 C2 37			add	dx,37h
 0000028F			@@cont:
 0000028F  88 16			mov	[esi],dl
 00000291  66| 46			inc	si
 00000293  66| 4F			dec	di
 00000295  75 E7			jnz	@@store

 00000297  5F				pop	edi
 00000298  5E				pop	esi
 00000299  5A				pop	edx
 0000029A  59				pop	ecx
 0000029B  5B				pop	ebx
 0000029C  58				pop	eax
					ret
 0000029D  C9		   *	    leave  
 0000029E  C2 0008	   *	    ret    00008h
 000002A1			dw2hex	endp

				end	start	                 

Microsoft (R) Macro Assembler Version 6.14.8444		    01/01/04 11:17:56
H:\programs\WIN32ASM\header\impexp.asm			     Page 1 - 1


				;WIN32 CONSOLE PROGRAM
				;see the imports bug
				.386
				.model flat, stdcall

				option casemap:none
				.nolist
				.listall
				includelib kernel32.lib
				includelib user32.lib
				includelib crtlib.lib
				includelib masm32.lib

				main proto stdcall :dword, :dword
				rva2offset PROto pFileMap:DWORD,RVA:DWORD 
				printfunc proto 	map1:dword,lpitd:dword

 00000000			.data
 00000000 00000000		rdhwnd	dd	?
 00000004 00000000		map	dd	?
 00000008 00000000		fmap	dd	?
 0000000C 00000000		imagebase	dd	?
 00000010 00000000		peoff	dd	?	
 00000014			.data

 00000000			.const

 00000000 45 72 72 6F 72	err1	db	"Error Opening File",0
	   20 4F 70 65 6E
	   69 6E 67 20 46
	   69 6C 65 00
 00000013 55 6E 61 62 6C	err2	db	"Unable to Map file into memory",0
	   65 20 74 6F 20
	   4D 61 70 20 66
	   69 6C 65 20 69
	   6E 74 6F 20 6D
	   65 6D 6F 72 79
	   00
 00000032 4D 65 6D 6F 72	err3	db	"Memory Map error",0
	   79 20 4D 61 70
	   20 65 72 72 6F
	   72 00
 00000043 54 68 65 20 66	err4	db	"The file is not a valid Portable Executable File",0
	   69 6C 65 20 69
	   73 20 6E 6F 74
	   20 61 20 76 61
	   6C 69 64 20 50
	   6F 72 74 61 62
	   6C 65 20 45 78
	   65 63 75 74 61
	   62 6C 65 20 46
	   69 6C 65 00
 00000074 44 75 6D 70 49	logo	db	"DumpIMPEXP - written by Madhur",10,13
	   4D 50 45 58 50
	   20 2D 20 77 72
	   69 74 74 65 6E
	   20 62 79 20 4D
	   61 64 68 75 72
	   0A 0D
 00000094  55 73 61 67 65		db	"Usage:	DLLDump <filename>",10,13,0
	   3A 09 44 4C 4C
	   44 75 6D 70 20
	   3C 66 69 6C 65
	   6E 61 6D 65 3E
	   0A 0D 00
					
 000000B0 3D 3D 3D 3D 3D	line1	db	"=============================================",10,13,0
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   0A 0D 00
 000000E0  46 75 6E 63 74		db	"Functions	Hint",10,13
	   69 6F 6E 73 09
	   48 69 6E 74 0A
	   0D
 000000F0  3D 3D 3D 3D 3D		db	"=========	====",10,13,0
	   3D 3D 3D 3D 09
	   3D 3D 3D 3D 0A
	   0D 00
 00000101 25 73 5C 74 25	impstr	db	"%s\t%x",0
	   78 00


 00000108 0A 0D 00		crlf	db	10,13,0
				closfile	macro
					invoke 	UnmapViewOfFile,map 
					invoke	CloseHandle,fmap
					invoke	CloseHandle,rdhwnd
				endm
 00000000			.code
 00000000			start:
 00000000  83 EC 0C		    sub     esp, 12
 00000003  8D 04 24		    lea     eax, [esp+0]    ; &env
 00000006  8D 4C 24 04		    lea     ecx, [esp+4]    ; &argc
 0000000A  8D 54 24 08		    lea     edx, [esp+8]    ; &argv
				    invoke  getmainargs, ecx, edx, eax, 0	;this call will put the env,argc,argv on stack,doesnt removes argument
 0000000E  6A 00	   *	    push   +000000000h
 00000010  50		   *	    push   eax
 00000011  52		   *	    push   edx
 00000012  51		   *	    push   ecx
 00000013  E8 00000000 E   *	    call   __GetMainArgs
 00000018  83 C4 10	   *	    add    esp, 000000010h
 0000001B  83 C4 04		    add     esp, 4          ; remove env (not used)
 0000001E  E8 00000006		    call    main
				    invoke  ExitProcess, eax
 00000023  50		   *	    push   eax
 00000024  E8 00000000 E   *	    call   ExitProcess

 00000029 00000029		main proc argc:dword, argv:dword
 00000029  55		   *	    push   ebp
 0000002A  8B EC	   *	    mov    ebp, esp
					.if	argc==1
 0000002C  83 7D 08 01	   *	    cmp    argc, 001h
 00000030  75 0E	   *	    jne    @C0001
						invoke	StdOut,offset logo
 00000032  68 00000074 R   *	    push   dword  ptr OFFSET FLAT:logo
 00000037  E8 00000000 E   *	    call   StdOut
						ret
 0000003C  C9		   *	    leave  
 0000003D  C2 0008	   *	    ret    00008h
					.endif
 00000040		   *@C0001:
 00000040  8B 4D 0C			mov	ecx,argv	;mov ecx,argv+4 won't work , discover why
 00000043  83 C1 04			add	ecx,4
					
					invoke	CreateFile,[ecx],GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0
 00000046  6A 00	   *	    push   +000000000h
 00000048  68 00000080	   *	    push   +000000080h
 0000004D  6A 03	   *	    push   +000000003h
 0000004F  6A 00	   *	    push   +000000000h
 00000051  6A 01	   *	    push   +000000001h
 00000053  68 80000000	   *	    push   +080000000h
 00000058  FF 31	   *	    push   dword  ptr [ecx]
 0000005A  E8 00000000 E   *	    call   CreateFileA
					.if	eax==INVALID_HANDLE_VALUE
 0000005F  83 F8 FF	   *	    cmp    eax, INVALID_HANDLE_VALUE
 00000062  75 0E	   *	    jne    @C0003
						invoke	StdOut,offset err1
 00000064  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:err1
 00000069  E8 00000000 E   *	    call   StdOut
						ret
 0000006E  C9		   *	    leave  
 0000006F  C2 0008	   *	    ret    00008h
					.endif
 00000072		   *@C0003:
 00000072  A3 00000000 R		mov	rdhwnd,eax
					invoke	CreateFileMapping,rdhwnd,0,PAGE_READONLY,0,0,0
 00000077  6A 00	   *	    push   +000000000h
 00000079  6A 00	   *	    push   +000000000h
 0000007B  6A 00	   *	    push   +000000000h
 0000007D  6A 02	   *	    push   +000000002h
 0000007F  6A 00	   *	    push   +000000000h
 00000081  FF 35 00000000 R *	    push   rdhwnd
 00000087  E8 00000000 E   *	    call   CreateFileMappingA
					.if	eax==0
 0000008C  0B C0	   *	    or	eax, eax
 0000008E  75 0F	   *	    jne    @C0005
						invoke	StdOut,offset err2
 00000090  68 00000013 R   *	    push   dword  ptr OFFSET FLAT:err2
 00000095  E8 00000000 E   *	    call   StdOut
 0000009A  E9 00000116				jmp	ret1
					.endif
 0000009F		   *@C0005:
 0000009F  A3 00000008 R		mov	fmap,eax
					invoke	MapViewOfFile,fmap,FILE_MAP_READ,0,0,0
 000000A4  6A 00	   *	    push   +000000000h
 000000A6  6A 00	   *	    push   +000000000h
 000000A8  6A 00	   *	    push   +000000000h
 000000AA  6A 04	   *	    push   +000000004h
 000000AC  FF 35 00000008 R *	    push   fmap
 000000B2  E8 00000000 E   *	    call   MapViewOfFile
					.if	eax==0
 000000B7  0B C0	   *	    or	eax, eax
 000000B9  75 0F	   *	    jne    @C0007
						invoke	StdOut,offset err2
 000000BB  68 00000013 R   *	    push   dword  ptr OFFSET FLAT:err2
 000000C0  E8 00000000 E   *	    call   StdOut
 000000C5  E9 000000EB				jmp	ret1
					.endif
 000000CA		   *@C0007:
									
 000000CA  A3 00000004 R		mov	map,eax
 000000CF  8B 3D 00000004 R		mov	edi,map
					assume edi:ptr IMAGE_DOS_HEADER 
				       .if [edi].e_magic==IMAGE_DOS_SIGNATURE 
 000000D5  66| 81 3F 5A4D  *	    cmp    [edi] . e_magic, IMAGE_DOS_SIGNATURE
 000000DA  75 3F	   *	    jne    @C0009
 000000DC  33 C0		       		xor	eax,eax
 000000DE  66| 8B 47 3C		                mov	ax,word ptr [edi].e_lfanew
 000000E2  03 F8		                add 	edi,eax
				                assume edi:ptr IMAGE_NT_HEADERS 
				                .if [edi].Signature==IMAGE_NT_SIGNATURE 
 000000E4  81 3F 00004550  *	    cmp    [edi] . Signature, IMAGE_NT_SIGNATURE
 000000EA  75 02	   *	    jne    @C000B
				                .else 
 000000EC  EB 58	   *	    jmp    @C000D
 000000EE		   *@C000B:
				                	invoke	StdOut,offset err4
 000000EE  68 00000043 R   *	    push   dword  ptr OFFSET FLAT:err4
 000000F3  E8 00000000 E   *	    call   StdOut
				                 	closfile
			     1		invoke 	UnmapViewOfFile,map 
 000000F8  FF 35 00000004 R *	    push   map
 000000FE  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 00000103  FF 35 00000008 R *	    push   fmap
 00000109  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 0000010E  FF 35 00000000 R *	    push   rdhwnd
 00000114  E8 00000000 E   *	    call   CloseHandle
				                .endif 
				         .else 
 00000119  EB 2B	   *	    jmp    @C000E
 0000011B		   *@C0009:
				         	invoke	StdOut,offset err4
 0000011B  68 00000043 R   *	    push   dword  ptr OFFSET FLAT:err4
 00000120  E8 00000000 E   *	    call   StdOut
				         	closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000125  FF 35 00000004 R *	    push   map
 0000012B  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 00000130  FF 35 00000008 R *	    push   fmap
 00000136  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 0000013B  FF 35 00000000 R *	    push   rdhwnd
 00000141  E8 00000000 E   *	    call   CloseHandle
				         .endif 
 00000146		   *@C000E:
 00000146		   *@C000D:
					
 00000146  8B 3D 00000004 R		mov	edi,map
					assume	edi:PTR IMAGE_DOS_HEADER
 0000014C  03 7F 3C			add	edi,[edi].e_lfanew
					m2m	peoff,[edi].e_lfanew			
 0000014F  FF 77 3C	     1		push	[edi].e_lfanew
 00000152  8F 05 00000010 R  1		pop	peoff
					assume	edi:ptr IMAGE_NT_HEADERS
 00000158  8B BF 00000080		mov 	edi, [edi].OptionalHeader.DataDirectory[sizeof IMAGE_DATA_DIRECTORY].VirtualAddress 

					;push	edi	;save edi(pe header) for future
				;ллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл	
 0000015E			printdll:	
					invoke	rva2offset,map,edi
 0000015E  57		   *	    push   edi
 0000015F  FF 35 00000004 R *	    push   map
 00000165  E8 00000097	   *	    call   rva2offset
 0000016A  03 05 00000004 R		add	eax,map
 00000170  8B 08			mov	ecx,dword ptr [eax]
 00000172  85 C9			test	ecx,ecx
 00000174  74 3F			jz	done

					assume	eax:ptr IMAGE_IMPORT_DESCRIPTOR
 00000176  8B 70 0C			mov	esi,[eax].Name1		;get the name of dll
					invoke	rva2offset,map,esi
 00000179  56		   *	    push   esi
 0000017A  FF 35 00000004 R *	    push   map
 00000180  E8 0000007C	   *	    call   rva2offset
 00000185  03 05 00000004 R		add	eax,map
 0000018B  E8 0000004A			call  	printinfo
				   	
				   	invoke	rva2offset,map,edi
 00000190  57		   *	    push   edi
 00000191  FF 35 00000004 R *	    push   map
 00000197  E8 00000065	   *	    call   rva2offset
 0000019C  03 05 00000004 R		add	eax,map
					assume	eax:ptr IMAGE_IMPORT_DESCRIPTOR
 000001A2  8B 30			mov	esi,[eax].Characteristics	;esi contains offset ofIMAGE_THUNK_DATA
				   	invoke	printfunc,map,esi	
 000001A4  56		   *	    push   esi
 000001A5  FF 35 00000004 R *	    push   map
 000001AB  E8 000000A6	   *	    call   printfunc

 000001B0  83 C7 14			add	edi,sizeof IMAGE_IMPORT_DESCRIPTOR
 000001B3  EB A9			jmp	printdll

				;ллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл




 000001B5			done:
					
 000001B5			ret1:
					closfile
			     1		invoke 	UnmapViewOfFile,map 
 000001B5  FF 35 00000004 R *	    push   map
 000001BB  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 000001C0  FF 35 00000008 R *	    push   fmap
 000001C6  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 000001CB  FF 35 00000000 R *	    push   rdhwnd
 000001D1  E8 00000000 E   *	    call   CloseHandle
					
					ret
 000001D6  C9		   *	    leave  
 000001D7  C2 0008	   *	    ret    00008h
 000001DA			main endp

 000001DA			printinfo proc

 000001DA  50				push	eax
					invoke	StdOut,offset crlf
 000001DB  68 00000108 R   *	    push   dword  ptr OFFSET FLAT:crlf
 000001E0  E8 00000000 E   *	    call   StdOut
 000001E5  58				pop	eax
					invoke	StdOut,eax
 000001E6  50		   *	    push   eax
 000001E7  E8 00000000 E   *	    call   StdOut
				   	invoke	StdOut,offset crlf
 000001EC  68 00000108 R   *	    push   dword  ptr OFFSET FLAT:crlf
 000001F1  E8 00000000 E   *	    call   StdOut
				   	invoke	StdOut,offset line1
 000001F6  68 000000B0 R   *	    push   dword  ptr OFFSET FLAT:line1
 000001FB  E8 00000000 E   *	    call   StdOut
 00000200  C3			   	ret
 00000201			printinfo endp
 00000201			rva2offset PROC uses edi esi edx ecx pFileMap:DWORD,RVA:DWORD 
 00000201  55		   *	    push   ebp
 00000202  8B EC	   *	    mov    ebp, esp
 00000204  57		   *	    push   edi
 00000205  56		   *	    push   esi
 00000206  52		   *	    push   edx
 00000207  51		   *	    push   ecx
 00000208  8B 75 08		   	mov 	esi,pFileMap 
				   	assume 	esi:ptr IMAGE_DOS_HEADER 
 0000020B  03 76 3C		   	add 	esi,[esi].e_lfanew 
				   	assume 	esi:ptr IMAGE_NT_HEADERS 
 0000020E  8B 7D 0C		   	mov 	edi,RVA ; edi == RVA 
 00000211  8B D6		   	mov 	edx,esi 
 00000213  81 C2 000000F8	   	add 	edx,sizeof IMAGE_NT_HEADERS 
 00000219  66| 8B 4E 06		   	mov 	cx,[esi].FileHeader.NumberOfSections 
 0000021D  0F B7 C9		   	movzx 	ecx,cx 
				   	assume 	edx:ptr IMAGE_SECTION_HEADER 
				   	.while 	ecx>0 ; check all sections 
 00000220  EB 25	   *	    jmp    @C000F
 00000222		   *@C0010:
				     		.if 	edi>=[edx].VirtualAddress 
 00000222  3B 7A 0C	   *	    cmp    edi, [edx] . VirtualAddress
 00000225  72 1C	   *	    jb     @C0011
 00000227  8B 42 0C		       			mov 	eax,[edx].VirtualAddress 
 0000022A  03 42 10		       			add 	eax,[edx].SizeOfRawData 
				       			.if 	edi<eax ; The address is in this section 
 0000022D  3B F8	   *	    cmp    edi, eax
 0000022F  73 12	   *	    jae    @C0013
 00000231  8B 42 0C		         			mov 	eax,[edx].VirtualAddress 
 00000234  2B F8		         			sub 	edi,eax
 00000236  8B 42 14		         			mov 	eax,[edx].PointerToRawData 
 00000239  03 C7		         			add 	eax,edi ; eax == file offset 
				         			ret 
 0000023B  59		   *	    pop    ecx
 0000023C  5A		   *	    pop    edx
 0000023D  5E		   *	    pop    esi
 0000023E  5F		   *	    pop    edi
 0000023F  C9		   *	    leave  
 00000240  C2 0008	   *	    ret    00008h
				       			.endif 
				     		.endif 
 00000243		   *@C0013:
 00000243		   *@C0011:
 00000243  83 C2 28		     		add	 edx,sizeof IMAGE_SECTION_HEADER 
 00000246  49			     		dec 	ecx 
				   	.endw 
 00000247		   *@C000F:
 00000247  83 F9 00	   *	    cmp    ecx, 000h
 0000024A  77 D6	   *	    ja     @C0010
				   	assume 	edx:nothing 
				   	assume 	esi:nothing 
 0000024C  8B C7		   	mov 	eax,edi 
				   	ret 
 0000024E  59		   *	    pop    ecx
 0000024F  5A		   *	    pop    edx
 00000250  5E		   *	    pop    esi
 00000251  5F		   *	    pop    edi
 00000252  C9		   *	    leave  
 00000253  C2 0008	   *	    ret    00008h
 00000256			rva2offset endp 

 00000256			printfunc proc uses esi eax ecx	map1:dword,lpitd:dword

 00000256  55		   *	    push   ebp
 00000257  8B EC	   *	    mov    ebp, esp
 00000259  56		   *	    push   esi
 0000025A  50		   *	    push   eax
 0000025B  51		   *	    push   ecx
 0000025C  8B 75 0C			mov	esi,lpitd
 0000025F			print:
					invoke	rva2offset,map,esi
 0000025F  56		   *	    push   esi
 00000260  FF 35 00000004 R *	    push   map
 00000266  E8 FFFFFF96	   *	    call   rva2offset
 0000026B  03 05 00000004 R		add	eax,map			
 00000271  8B 08			mov	ecx,dword ptr [eax]
 00000273  85 C9			test	ecx,ecx
 00000275  74 3B			jz	done
					
					invoke	rva2offset,map,ecx
 00000277  51		   *	    push   ecx
 00000278  FF 35 00000004 R *	    push   map
 0000027E  E8 FFFFFF7E	   *	    call   rva2offset
 00000283  03 05 00000004 R		add	eax,map
 00000289  8B C8			mov	ecx,eax
					
					assume	eax:ptr IMAGE_IMPORT_BY_NAME
 0000028B  66| 8B 08			mov	cx,word ptr [eax]	;get hint in ecx
 0000028E  0F B7 C9			movzx	ecx,cx
 00000291  83 C0 02			add	eax,2
					invoke	printf,offset impstr,eax,ecx
 00000294  51		   *	    push   ecx
 00000295  50		   *	    push   eax
 00000296  68 00000101 R   *	    push   dword  ptr OFFSET FLAT:impstr
 0000029B  E8 00000000 E   *	    call   printf
 000002A0  83 C4 0C	   *	    add    esp, 00000000Ch
					invoke	StdOut,offset crlf
 000002A3  68 00000108 R   *	    push   dword  ptr OFFSET FLAT:crlf
 000002A8  E8 00000000 E   *	    call   StdOut
					
 000002AD  83 C6 04			add	esi,sizeof IMAGE_THUNK_DATA
 000002B0  EB AD			jmp	print
 000002B2			done:
					ret
 000002B2  59		   *	    pop    ecx
 000002B3  58		   *	    pop    eax
 000002B4  5E		   *	    pop    esi
 000002B5  C9		   *	    leave  
 000002B6  C2 0008	   *	    ret    00008h
					
 000002B9			printfunc	endp

				end start

Microsoft (R) Macro Assembler Version 6.14.8444		    12/29/03 01:24:34
H:\programs\WIN32ASM\header\head.asm			     Page 1 - 1


				;###################################################
				;	Description:	File Header Program 	
				;	Version:  	1.0             
				; 	Author:		Madhur               
				;	Start Date: 	03/08/03,14:47:10                     
				;	Name:  		HEADER.ASM
				;	Assembler:  	MASM 6.14.8444
				;	Linker:  	Link.exe 5.12.8078
				;###################################################
				.386
				.model	flat,stdcall
				option 	casemap:none
				.nolist
				.listall
				includelib masm32.lib
				includelib user32.lib
				includelib kernel32.lib
				;##########################################################
 00000000			.data
 00000000  00000064 [		prog	db	100 dup(0)
	    00
	   ]
 00000064  00000014 [		buff	db	20 dup(0)
	    00
	   ]

 00000078 00000073		zero		dd	115
 0000007C 0000007E		first		dd	126
 00000080 0000007A		second		dd	122
 00000084 0000007C		third		dd	124	


 00000024			OFFSETS struct		;structure containing offsets to various structures
 00000000  00000000		dosmz	dd	0
 00000004  00000000		dosstub	dd	0
 00000008  00000000		pehead	dd	0
 0000000C  00000000		pesign	dd	0
 00000010  00000000		ifh	dd	0
 00000014  00000000		oh	dd	0
 00000018  00000000		sect	dd	0
 0000001C  00000000		impt	dd	0
 00000020  00000000		expt	dd	0
				OFFSETS ENDS
 00000088 00000000		offsets OFFSETS <0>
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000

				;x

 0000001C			HEAD struct		;structure for dos mz header
 00000000  0000			sig	dw	0
 00000002  0000			lblksz	dw	0
 00000004  0000			sizefile dw	0
 00000006  0000			reloct	dw	0
 00000008  0000			sizhead	dw	0
 0000000A  0000			cpara	dw	0
 0000000C  0000			switch	dw	0
 0000000E  0000			ofstak	dw	0
 00000010  0000			ofsp	dw	0
 00000012  0000			cheksum	dw	0
 00000014  0000			offst	dw	0
 00000016  0000			offcs	dw	0
 00000018  0000			offrel	dw	0
 0000001A  0000			overlay	dw	0
				HEAD	ends
 000000AC 0000 0000 0000	head	HEAD	<0>
	   0000 0000 0000
	   0000 0000 0000
	   0000 0000 0000
	   0000 0000

 000000C8 0000 0000		ifh	IMAGE_FILE_HEADER <0>
	   00000000
	   00000000
	   00000000 0000
	   0000
 000000DC 0000 00 00		ioh	IMAGE_OPTIONAL_HEADER <>
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000 0000
	   0000 0000 0000
	   0000 0000
	   00000000
	   00000000
	   00000000
	   00000000 0000
	   0000 00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000010 [
	    00000000
	    00000000
	   ]
 000001BC  00000008 [		ish	IMAGE_SECTION_HEADER <>
	    00
	   ] 00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000 0000
	   0000 00000000

 000001E4 0000			sections	dw		0
 000001E6 00000000		offpesig	dd		0
 000001EA 00000000		pesig		dd		0
				;##########################################################
 00000000			.data?
 00000000 00000000		hinst	HINSTANCE	?
 00000004 00000000		cmdline	dd		?

 00000008 00000000		memadd	dd	?
 0000000C 00000000		offhex	dd	?
 00000010 00000000		offdec	dd	?
 00000014 00000000		rdhwnd	dd	?
 00000018  00000032 [		file	db	50 dup(?)
	    00
	   ]
 0000004A  00000032 [		buffer	db	50 dup(?)
	    00
	   ]
 0000007C 00000000		fmap	dd	?
 00000080 00000000		map	dd	?
 00000084 00000000		ofn	OPENFILENAME <?>
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000 0000
	   0000 00000000
	   00000000
	   00000000
	   00000000
 000000D0 00000000		msg	MSGBOXPARAMS <?>
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
	   00000000
 000000F8 00			fopen	db	?	;flag whether file is opened
 000000F9 00000000		iconh	dd	?
 000000FD 00000000		peoff	dd	?
				;##########################################################
 00000000			.const
				dlgproc		proto	hwnd:HWND,umsg:DWORD,wparam:WPARAM,lparam:LPARAM
				dlgprocabt 	proto 	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				hexit		proto	:dword,:dword,:dword
				pedlgproc	proto	hwnd:HWND,umsg:DWORD,wparam:WPARAM,lparam:LPARAM
				optdlgproc	proto	hwnd:HWND,umsg:DWORD,wparam:WPARAM,lparam:LPARAM
				secdlgproc	proto 	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				gendlgproc	proto 	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				;##########################################################
 00000000 46 69 6C 65 20	msgtitle	db	'File Header',0
	   48 65 61 64 65
	   72 00
 = 00000000			caption	equ	msgtitle
 0000000C 20 2D 20 46 69	title1		db	' - File Header',0
	   6C 65 20 48 65
	   61 64 65 72 00
 0000001B 44 49 41 4C 4F	dialog		db	'DIALOG',0,0
	   47 00 00
 00000023 49 44 44 5F 50	pedialog	db	'IDD_PEVIEW',0
	   45 56 49 45 57
	   00
 0000002E 49 44 44 5F 4F	optdialog	db	'IDD_OPTHEADER',0
	   50 54 48 45 41
	   44 45 52 00
 0000003C 49 44 44 5F 53	secdialog	db	'IDD_SECTION',0
	   45 43 54 49 4F
	   4E 00
 00000048 49 44 44 5F 47	gendialog	db	'IDD_GENERAL',0
	   45 4E 45 52 41
	   4C 00
 00000054 68 65 61 64 65	err1		db	'header.exe doesnt run directly,run installer to add it to right click menu',0
	   72 2E 65 78 65
	   20 64 6F 65 73
	   6E 74 20 72 75
	   6E 20 64 69 72
	   65 63 74 6C 79
	   2C 72 75 6E 20
	   69 6E 73 74 61
	   6C 6C 65 72 20
	   74 6F 20 61 64
	   64 20 69 74 20
	   74 6F 20 72 69
	   67 68 74 20 63
	   6C 69 63 6B 20
	   6D 65 6E 75 00
 0000009F 46 61 74 61 6C	err2		db	'Fatal Error: Cannot Open File',0
	   20 45 72 72 6F
	   72 3A 20 43 61
	   6E 6E 6F 74 20
	   4F 70 65 6E 20
	   46 69 6C 65 00
 000000BD 49 44 44 5F 41	abtdialog	db	'IDD_ABTDIALOG',0	
	   42 54 44 49 41
	   4C 4F 47 00
 000000CB 2D 2D 2D 2D 00	notap		db	'----',0
 000000D0 02 02 04 04 04	offifh		db	2,2,4,4,4,2,2		;offset to increment
	   02 02
 000000D7 02 01 01 04 04	offioh		db	2,1,1,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,4,4,4,4,2,2,4,4,4,4,4,4
	   04 04 04 04 04
	   04 04 02 02 02
	   02 02 02 04 04
	   04 04 02 02 04
	   04 04 04 04 04
 000000F5 04 04 04 04 04	offish		db	4,4,4,4,4,4,2,2,4
	   04 02 02 04
 000000FE 45 78 70 6F 72	imagedata	db	"Export Symbols",0,6 dup(0)
	   74 20 53 79 6D
	   62 6F 6C 73 00
	   00000006 [
	    00
	   ]
 00000113  49 6D 70 6F 72			db	"Import Symbols",0,6 dup(0)
	   74 20 53 79 6D
	   62 6F 6C 73 00
	   00000006 [
	    00
	   ]
 00000128  52 65 73 6F 75			db	"Resources",0,11 dup(0)
	   72 63 65 73 00
	   0000000B [
	    00
	   ]
 0000013D  45 78 63 65 70			db	"Exception",0,10 dup(0)
	   74 69 6F 6E 00
	   0000000A [
	    00
	   ]
 00000151  53 65 63 75 72			db	"Security",0,11 dup(0)
	   69 74 79 00
	   0000000B [
	    00
	   ]
 00000165  42 61 73 65 20			db	"Base Relocation",0,5 dup(0)
	   52 65 6C 6F 63
	   61 74 69 6F 6E
	   00
	   00000005 [
	    00
	   ]
 0000017A  44 65 62 75 67			db	"Debug",0,15 dup(0)
	   00
	   0000000F [
	    00
	   ]
 0000018F  43 6F 70 79 72			db	"Copyright String",0,4 dup(0)
	   69 67 68 74 20
	   53 74 72 69 6E
	   67 00
	   00000004 [
	    00
	   ]
 000001A4  55 6E 6B 6E 6F			db	"Unknown",0,12 dup(0)
	   77 6E 00
	   0000000C [
	    00
	   ]
 000001B8  54 68 72 65 61			db	"Thread Local storage",0
	   64 20 4C 6F 63
	   61 6C 20 73 74
	   6F 72 61 67 65
	   00
 000001CD  4C 6F 61 64 20			db	"Load Configuration",0,2 dup(0)
	   43 6F 6E 66 69
	   67 75 72 61 74
	   69 6F 6E 00
	   00000002 [
	    00
	   ]
 000001E2  42 6F 75 6E 64			db	"Bound Import",0,8 dup(0)
	   20 49 6D 70 6F
	   72 74 00
 000001F7  49 6D 70 6F 72			db	"Import Address Table",0
	   74 20 41 64 64
	   72 65 73 73 20
	   54 61 62 6C 65
	   00
 0000020C  44 65 6C 61 79			db	"Delay Import",0,8 dup(0)
	   20 49 6D 70 6F
	   72 74 00
 00000221  43 4F 4D 20 44			db	"COM Descriptor",0,6 dup(0)
	   65 73 63 72 69
	   70 74 6F 72 00
	   00000006 [
	    00
	   ]

 00000236 45 72 72 6F 72	err11	db	"Error Opening File",0
	   20 4F 70 65 6E
	   69 6E 67 20 46
	   69 6C 65 00
 00000249 55 6E 61 62 6C	err21	db	"Unable to Map file into memory",0
	   65 20 74 6F 20
	   4D 61 70 20 66
	   69 6C 65 20 69
	   6E 74 6F 20 6D
	   65 6D 6F 72 79
	   00
 00000268 4D 65 6D 6F 72	err3	db	"Memory Map error",0
	   79 20 4D 61 70
	   20 65 72 72 6F
	   72 00
 00000279 54 68 65 20 66	err4	db	"The file is not a valid Portable Executable File",0
	   69 6C 65 20 69
	   73 20 6E 6F 74
	   20 61 20 76 61
	   6C 69 64 20 50
	   6F 72 74 61 62
	   6C 65 20 45 78
	   65 63 75 74 61
	   62 6C 65 20 46
	   69 6C 65 00
 000002AA 54 68 65 20 73	err5	db	"The specified memory address is not a valid address",0
	   70 65 63 69 66
	   69 65 64 20 6D
	   65 6D 6F 72 79
	   20 61 64 64 72
	   65 73 73 20 69
	   73 20 6E 6F 74
	   20 61 20 76 61
	   6C 69 64 20 61
	   64 64 72 65 73
	   73 00
 000002DE 54 68 65 20 73	err6	db	"The specified address was not found in the file",13,10
	   70 65 63 69 66
	   69 65 64 20 61
	   64 64 72 65 73
	   73 20 77 61 73
	   20 6E 6F 74 20
	   66 6F 75 6E 64
	   20 69 6E 20 74
	   68 65 20 66 69
	   6C 65 0D 0A
 0000030F  4D 6F 73 74 20		db	"Most likely,it falls in the section gaps",0
	   6C 69 6B 65 6C
	   79 2C 69 74 20
	   66 61 6C 6C 73
	   20 69 6E 20 74
	   68 65 20 73 65
	   63 74 69 6F 6E
	   20 67 61 70 73
	   00

						;disp data in hex
				;##########################################################
 = 00000073			IDC_EDIT1	equ	115
 = 00000001			IDC_ABOUT	equ	1
 = 00000066			IDC_OK		EQU	102
 = 00000085			IDC_STATUS	EQU	133
 = 0000003C			offlfanew	EQU	3ch	;offset where the offset of pe header signature is found
 = 00000002			IDC_PEVIEW	EQU	2
 = 0000006F			IDC_DOSHEAD	EQU	111
 = 00000070			IDC_SECTION	EQU	112
 = 00000071			IDC_OPTION	EQU	113
 = 0000007D			IDC_IFH		EQU	125
 = 0000006A			IDC_NEXTSEC	EQU	106
 = 00000073			FIRSTEDIT	EQU	115
 = 0000007C			LASTEDIT	EQU	FIRSTEDIT +9
 = 0000006A			IDC_IMAGEDATADIRECTORY EQU 106

				closfile	macro
					invoke 	UnmapViewOfFile,map 
					invoke	CloseHandle,fmap
					invoke	CloseHandle,rdhwnd
				endm
				;##########################################################
 00000000			.code
 00000000			start:
 00000000				invoke	GetModuleHandle,NULL
 00000000  6A 00	   *	    push   +000000000h
 00000002  E8 00000000 E   *	    call   GetModuleHandleA
 00000007  A3 00000000 R		mov	[hinst],eax
					invoke	GetCommandLine
 0000000C  E8 00000000 E   *	    call   GetCommandLineA
 00000011  A3 00000004 R		mov	cmdline,eax
 00000016  E8 00000A6F			call	getprog
					.if	[prog+1]==0	
 0000001B  80 3D 00000001 R
	   00		   *	    cmp    [prog + 001h], 000h
 00000022  75 1A	   *	    jne    @C0001
						invoke	MessageBox,0,addr err1,addr msgtitle,MB_ICONEXCLAMATION
 00000024  6A 30	   *	    push   +000000030h
 00000026  68 00000000 R   *	    push   OFFSET msgtitle
 0000002B  68 00000054 R   *	    push   OFFSET err1
 00000030  6A 00	   *	    push   +000000000h
 00000032  E8 00000000 E   *	    call   MessageBoxA
						invoke	ExitProcess,0
 00000037  6A 00	   *	    push   +000000000h
 00000039  E8 00000000 E   *	    call   ExitProcess
					.endif
 0000003E		   *@C0001:
								invoke	CreateFile,offset prog+1,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0
 0000003E  6A 00	   *	    push   +000000000h
 00000040  68 00000080	   *	    push   +000000080h
 00000045  6A 03	   *	    push   +000000003h
 00000047  6A 00	   *	    push   +000000000h
 00000049  6A 01	   *	    push   +000000001h
 0000004B  68 80000000	   *	    push   +080000000h
 00000050  68 00000001 R   *	    push   dword  ptr OFFSET FLAT:prog+000000001h
 00000055  E8 00000000 E   *	    call   CreateFileA
								.if	eax==INVALID_HANDLE_VALUE
 0000005A  83 F8 FF	   *	    cmp    eax, INVALID_HANDLE_VALUE
 0000005D  75 18	   *	    jne    @C0003
									invoke	MessageBox,0,offset err1,offset caption,MB_ICONSTOP
 0000005F  6A 10	   *	    push   +000000010h
 00000061  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:msgtitle
 00000066  68 00000054 R   *	    push   dword  ptr OFFSET FLAT:err1
 0000006B  6A 00	   *	    push   +000000000h
 0000006D  E8 00000000 E   *	    call   MessageBoxA
								.else
 00000072  E9 00000141	   *	    jmp    @C0005
 00000077		   *@C0003:
 00000077  A3 00000014 R						mov	rdhwnd,eax
									
									invoke	CreateFileMapping,rdhwnd,0,PAGE_READONLY,0,0,0
 0000007C  6A 00	   *	    push   +000000000h
 0000007E  6A 00	   *	    push   +000000000h
 00000080  6A 00	   *	    push   +000000000h
 00000082  6A 02	   *	    push   +000000002h
 00000084  6A 00	   *	    push   +000000000h
 00000086  FF 35 00000014 R *	    push   rdhwnd
 0000008C  E8 00000000 E   *	    call   CreateFileMappingA
									.if	eax==0
 00000091  0B C0	   *	    or	eax, eax
 00000093  75 39	   *	    jne    @C0006
										closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000095  FF 35 00000080 R *	    push   map
 0000009B  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 000000A0  FF 35 0000007C R *	    push   fmap
 000000A6  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 000000AB  FF 35 00000014 R *	    push   rdhwnd
 000000B1  E8 00000000 E   *	    call   CloseHandle
										invoke	MessageBox,0,offset err2,offset caption,MB_ICONSTOP
 000000B6  6A 10	   *	    push   +000000010h
 000000B8  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:msgtitle
 000000BD  68 0000009F R   *	    push   dword  ptr OFFSET FLAT:err2
 000000C2  6A 00	   *	    push   +000000000h
 000000C4  E8 00000000 E   *	    call   MessageBoxA
									.else
 000000C9  E9 000000EA	   *	    jmp    @C0008
 000000CE		   *@C0006:
 000000CE  A3 0000007C R							mov	fmap,eax
										invoke	MapViewOfFile,fmap,FILE_MAP_READ,0,0,0
 000000D3  6A 00	   *	    push   +000000000h
 000000D5  6A 00	   *	    push   +000000000h
 000000D7  6A 00	   *	    push   +000000000h
 000000D9  6A 04	   *	    push   +000000004h
 000000DB  FF 35 0000007C R *	    push   fmap
 000000E1  E8 00000000 E   *	    call   MapViewOfFile
										.if	eax==0
 000000E6  0B C0	   *	    or	eax, eax
 000000E8  75 39	   *	    jne    @C0009
											invoke	MessageBox,0,offset err2,offset caption,MB_ICONSTOP
 000000EA  6A 10	   *	    push   +000000010h
 000000EC  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:msgtitle
 000000F1  68 0000009F R   *	    push   dword  ptr OFFSET FLAT:err2
 000000F6  6A 00	   *	    push   +000000000h
 000000F8  E8 00000000 E   *	    call   MessageBoxA
											closfile
			     1		invoke 	UnmapViewOfFile,map 
 000000FD  FF 35 00000080 R *	    push   map
 00000103  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 00000108  FF 35 0000007C R *	    push   fmap
 0000010E  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 00000113  FF 35 00000014 R *	    push   rdhwnd
 00000119  E8 00000000 E   *	    call   CloseHandle
										.else
 0000011E  E9 00000095	   *	    jmp    @C000B
 00000123		   *@C0009:
 00000123  A3 00000080 R								mov	map,eax
											
 00000128  8B 3D 00000080 R								mov	edi,map
											assume edi:ptr IMAGE_DOS_HEADER 
									               .if [edi].e_magic==IMAGE_DOS_SIGNATURE 
 0000012E  66| 81 3F 5A4D  *	    cmp    [edi] . e_magic, IMAGE_DOS_SIGNATURE
 00000133  75 4F	   *	    jne    @C000C
 00000135  33 C0		                  						xor	eax,eax
 00000137  66| 8B 47 3C		                  						mov	ax,word ptr [edi].e_lfanew
 0000013B  03 F8		                  						add 	edi,eax
				                  						assume edi:ptr IMAGE_NT_HEADERS 
				                  						.if [edi].Signature==IMAGE_NT_SIGNATURE 
 0000013D  81 3F 00004550  *	    cmp    [edi] . Signature, IMAGE_NT_SIGNATURE
 00000143  75 09	   *	    jne    @C000E
				                     							;mov ValidPE, TRUE 
 00000145  C6 05 000000F8 R	                     							mov	fopen,1
	   01
				                  						.else 
 0000014C  EB 6A	   *	    jmp    @C0010
 0000014E		   *@C000E:
				                     							invoke	MessageBox,0,offset err4,offset caption,MB_ICONSTOP
 0000014E  6A 10	   *	    push   +000000010h
 00000150  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:msgtitle
 00000155  68 00000279 R   *	    push   dword  ptr OFFSET FLAT:err4
 0000015A  6A 00	   *	    push   +000000000h
 0000015C  E8 00000000 E   *	    call   MessageBoxA
				                     							;mov ValidPE, FALSE 
				                  							closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000161  FF 35 00000080 R *	    push   map
 00000167  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 0000016C  FF 35 0000007C R *	    push   fmap
 00000172  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 00000177  FF 35 00000014 R *	    push   rdhwnd
 0000017D  E8 00000000 E   *	    call   CloseHandle
				                  						.endif 
				               						.else 
 00000182  EB 34	   *	    jmp    @C0011
 00000184		   *@C000C:
				                  						invoke	MessageBox,0,offset err4,offset caption,MB_ICONSTOP
 00000184  6A 10	   *	    push   +000000010h
 00000186  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:msgtitle
 0000018B  68 00000279 R   *	    push   dword  ptr OFFSET FLAT:err4
 00000190  6A 00	   *	    push   +000000000h
 00000192  E8 00000000 E   *	    call   MessageBoxA
				                  						;mov ValidPE,FALSE 
				                  						closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000197  FF 35 00000080 R *	    push   map
 0000019D  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 000001A2  FF 35 0000007C R *	    push   fmap
 000001A8  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 000001AD  FF 35 00000014 R *	    push   rdhwnd
 000001B3  E8 00000000 E   *	    call   CloseHandle
				               						.endif 
					
										
										
										.endif
 000001B8		   *@C0011:
 000001B8		   *@C0010:
									.endif
 000001B8		   *@C000B:
								.endif
 000001B8		   *@C0008:
 000001B8		   *@C0005:
						
					
 000001B8  A3 00000014 R		mov	rdhwnd,eax
					invoke	szCatStr,addr prog,addr title1
 000001BD  68 0000000C R   *	    push   OFFSET title1
 000001C2  68 00000000 R   *	    push   OFFSET prog
 000001C7  E8 00000000 E   *	    call   szCatStr
					invoke	DialogBoxParam,hinst,offset gendialog,0,addr gendlgproc,0
 000001CC  6A 00	   *	    push   +000000000h
 000001CE  68 00000637 R   *	    push   gendlgproc
 000001D3  6A 00	   *	    push   +000000000h
 000001D5  68 00000048 R   *	    push   dword  ptr OFFSET FLAT:gendialog
 000001DA  FF 35 00000000 R *	    push   hinst
 000001E0  E8 00000000 E   *	    call   DialogBoxParamA
					invoke	_lclose,rdhwnd	
 000001E5  FF 35 00000014 R *	    push   rdhwnd
 000001EB  E8 00000000 E   *	    call   _lclose
					invoke	ExitProcess,0
 000001F0  6A 00	   *	    push   +000000000h
 000001F2  E8 00000000 E   *	    call   ExitProcess
					
				;##########################################################
				;this dialog box displays dos mz header
				;##########################################################	

 000001F7 000001F7		dlgproc	proc uses esi edi ebx	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				local counter:byte
 000001F7  55		   *	    push   ebp
 000001F8  8B EC	   *	    mov    ebp, esp
 000001FA  83 C4 FC	   *	    add    esp, 0FFFFFFFCh
 000001FD  56		   *	    push   esi
 000001FE  57		   *	    push   edi
 000001FF  53		   *	    push   ebx
					.if	uMsg==WM_INITDIALOG
 00000200  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000207  0F 85 000000AB  *	    jne    @C0012
 0000020D  C6 45 FF 00				mov	counter,0
						;invoke	_llseek,rdhwnd,offsets.dosmz,FILE_BEGIN
						;invoke	_lread,rdhwnd,addr head,28
 00000211  8B 0D 00000080 R			mov	ecx,map
						assume	ecx:ptr IMAGE_DOS_HEADER
						
						
						invoke	SetWindowText,hwnd,offset prog
 00000217  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:prog
 0000021C  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000021F  E8 00000000 E   *	    call   SetWindowTextA
 00000224  33 F6				xor	esi,esi
 00000226  BF 00000073				mov	edi,IDC_EDIT1
						.while	edi!=129
 0000022B  EB 20	   *	    jmp    @C0014
 0000022D		   *@C0015:
							invoke	hexit,dword ptr[ecx+esi],addr buff,4
 0000022D  6A 04	   *	    push   +000000004h
 0000022F  68 00000064 R   *	    push   OFFSET buff
 00000234  FF 34 0E	   *	    push   dword  ptr [esi+ecx]
 00000237  E8 0000088B	   *	    call   hexit
							invoke	SetDlgItemText,hwnd,edi,offset buff
 0000023C  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 00000241  57		   *	    push   edi
 00000242  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000245  E8 00000000 E   *	    call   SetDlgItemTextA
 0000024A  46						inc	esi
 0000024B  46						inc	esi
 0000024C  47						inc	edi
						.endw
 0000024D		   *@C0014:
 0000024D  81 FF 00000081  *	    cmp    edi, 081h
 00000253  75 D8	   *	    jne    @C0015
 00000255  8B 0D 00000080 R			mov	ecx,map
 0000025B  03 49 3C				add	ecx,[ecx].e_lfanew
 0000025E  89 0D 000000FD R			mov	peoff,ecx
						assume	ecx:PTR IMAGE_NT_HEADERS
						;invoke	_llseek,rdhwnd,offsets.pesign,FILE_BEGIN
						;invoke	_lread,rdhwnd,offset pesig,4
						invoke	dw2hex,[ecx].Signature,offset buff
 00000264  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 00000269  FF 31	   *	    push   dword  ptr [ecx]
 0000026B  E8 00000000 E   *	    call   dw2hex
						
						.if	[ecx].Signature==IMAGE_NT_SIGNATURE
 00000270  81 39 00004550  *	    cmp    [ecx] . Signature, IMAGE_NT_SIGNATURE
 00000276  75 29	   *	    jne    @C0017
							invoke	SetDlgItemText,hwnd,129,offset buff	;set address of pe header
 00000278  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 0000027D  68 00000081	   *	    push   +000000081h
 00000282  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000285  E8 00000000 E   *	    call   SetDlgItemTextA
							invoke	GetDlgItem,hwnd,IDC_PEVIEW
 0000028A  6A 02	   *	    push   +000000002h
 0000028C  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000028F  E8 00000000 E   *	    call   GetDlgItem
							invoke	EnableWindow,eax,TRUE
 00000294  6A 01	   *	    push   +000000001h
 00000296  50		   *	    push   eax
 00000297  E8 00000000 E   *	    call   EnableWindow
						.else
 0000029C  E9 000000A9	   *	    jmp    @C0019
 000002A1		   *@C0017:
							invoke	SetDlgItemText,hwnd,129,offset notap	;file is not pe ,set blank
 000002A1  68 000000CB R   *	    push   dword  ptr OFFSET FLAT:notap
 000002A6  68 00000081	   *	    push   +000000081h
 000002AB  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000002AE  E8 00000000 E   *	    call   SetDlgItemTextA
						.endif
						
					.elseif	uMsg==WM_COMMAND
 000002B3  E9 00000092	   *	    jmp    @C001A
 000002B8		   *@C0012:
 000002B8  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 000002BF  75 6B	   *	    jne    @C001B
 000002C1  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK	
 000002C4  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 000002C8  75 10	   *	    jne    @C001D
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000002CA  6A 00	   *	    push   +000000000h
 000002CC  6A 00	   *	    push   +000000000h
 000002CE  6A 10	   *	    push   +000000010h
 000002D0  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000002D3  E8 00000000 E   *	    call   SendMessageA
						
						.elseif	ax==IDC_ABOUT
 000002D8  EB 70	   *	    jmp    @C001F
 000002DA		   *@C001D:
 000002DA  66| 83 F8 01	   *	    cmp    ax, IDC_ABOUT
 000002DE  75 1C	   *	    jne    @C0020
							invoke	DialogBoxParam,hinst,addr abtdialog,hwnd,dlgprocabt,0
 000002E0  6A 00	   *	    push   +000000000h
 000002E2  68 00000A45 R   *	    push   dlgprocabt
 000002E7  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000002EA  68 000000BD R   *	    push   OFFSET abtdialog
 000002EF  FF 35 00000000 R *	    push   hinst
 000002F5  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_PEVIEW
 000002FA  EB 4E	   *	    jmp    @C0022
 000002FC		   *@C0020:
 000002FC  66| 83 F8 02	   *	    cmp    ax, IDC_PEVIEW
 00000300  75 48	   *	    jne    @C0023
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 00000302  6A 00	   *	    push   +000000000h
 00000304  6A 00	   *	    push   +000000000h
 00000306  6A 10	   *	    push   +000000010h
 00000308  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000030B  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,addr gendialog,hwnd,gendlgproc,0	;pass the handle so that disp it
 00000310  6A 00	   *	    push   +000000000h
 00000312  68 00000637 R   *	    push   gendlgproc
 00000317  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000031A  68 00000048 R   *	    push   OFFSET gendialog
 0000031F  FF 35 00000000 R *	    push   hinst
 00000325  E8 00000000 E   *	    call   DialogBoxParamA
						.endif			
					.elseif	uMsg==WM_CLOSE
 0000032A  EB 1E	   *	    jmp    @C0025
 0000032C		   *@C001B:
 0000032C  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 00000330  75 0C	   *	    jne    @C0026
						invoke	EndDialog,hwnd,0
 00000332  6A 00	   *	    push   +000000000h
 00000334  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000337  E8 00000000 E   *	    call   EndDialog
					.else
 0000033C  EB 0C	   *	    jmp    @C0028
 0000033E		   *@C0026:
 0000033E  B8 00000000				mov	eax,FALSE
						ret
 00000343  5B		   *	    pop    ebx
 00000344  5F		   *	    pop    edi
 00000345  5E		   *	    pop    esi
 00000346  C9		   *	    leave  
 00000347  C2 0010	   *	    ret    00010h
					.endif
 0000034A		   *@C0028:
 0000034A		   *@C0025:
 0000034A		   *@C001A:
 0000034A		   *@C0019:
 0000034A		   *@C0023:
 0000034A		   *@C0022:
 0000034A		   *@C001F:
 0000034A  B8 00000001			mov	eax,TRUE
					ret												                   		              
 0000034F  5B		   *	    pop    ebx
 00000350  5F		   *	    pop    edi
 00000351  5E		   *	    pop    esi
 00000352  C9		   *	    leave  
 00000353  C2 0010	   *	    ret    00010h
 00000356			dlgproc	endp	
				;##########################################################

				;##########################################################

 00000356			pedlgproc	proc uses esi edi ebx	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 00000356  55		   *	    push   ebp
 00000357  8B EC	   *	    mov    ebp, esp
 00000359  56		   *	    push   esi
 0000035A  57		   *	    push   edi
 0000035B  53		   *	    push   ebx
					.if	uMsg==WM_INITDIALOG
 0000035C  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000363  75 62	   *	    jne    @C0029
						;invoke	_llseek,rdhwnd,offlfanew,FILE_BEGIN
						;invoke	_lread,rdhwnd,addr offpesig,4
						
						;mov	eax,offpesig
						;add	eax,4
						;invoke	_llseek,rdhwnd,eax,FILE_BEGIN	;read the offset from last byte of signature
						;invoke	_lread,rdhwnd,offset offset ifh,20	;ifh=20 bytes
 00000365  8B 0D 000000FD R			mov	ecx,peoff
						assume	ecx:ptr IMAGE_NT_HEADERS
 0000036B  83 C1 04				add	ecx,4
						
						invoke	SetWindowText,hwnd,offset prog
 0000036E  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:prog
 00000373  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000376  E8 00000000 E   *	    call   SetWindowTextA
						;xor	esi,esi
						;lea	esi,offifh
 0000037B  33 D2				xor	edx,edx
 0000037D  BF 00000073				mov	edi,115
						.while	edi!=122
 00000382  EB 39	   *	    jmp    @C002B
 00000384		   *@C002C:
							.if	edi>116 && edi<120
 00000384  83 FF 74	   *	    cmp    edi, 074h
 00000387  76 14	   *	    jbe    @C002D
 00000389  83 FF 78	   *	    cmp    edi, 078h
 0000038C  73 0F	   *	    jae    @C002D
								invoke	hexit,dword ptr ecx,addr buff,8
 0000038E  6A 08	   *	    push   +000000008h
 00000390  68 00000064 R   *	    push   OFFSET buff
 00000395  51		   *	    push   ecx
 00000396  E8 0000072C	   *	    call   hexit
							.else
 0000039B  EB 0D	   *	    jmp    @C0030
 0000039D		   *@C002D:
								invoke	hexit,dword ptr ecx,addr buff,4
 0000039D  6A 04	   *	    push   +000000004h
 0000039F  68 00000064 R   *	    push   OFFSET buff
 000003A4  51		   *	    push   ecx
 000003A5  E8 0000071D	   *	    call   hexit
							.endif
							invoke	SetDlgItemText,hwnd,edi,offset buff
 000003AA		   *@C0030:
 000003AA  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 000003AF  57		   *	    push   edi
 000003B0  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000003B3  E8 00000000 E   *	    call   SetDlgItemTextA
 000003B8  83 C1 04					add	ecx,4
 000003BB  46						inc	esi
 000003BC  47						inc	edi
						.endw
 000003BD		   *@C002B:
 000003BD  83 FF 7A	   *	    cmp    edi, 07Ah
 000003C0  75 C2	   *	    jne    @C002C
						
					.elseif	uMsg==WM_COMMAND
 000003C2  E9 00000091	   *	    jmp    @C0032
 000003C7		   *@C0029:
 000003C7  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 000003CE  75 6A	   *	    jne    @C0033
 000003D0  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK	
 000003D3  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 000003D7  75 10	   *	    jne    @C0035
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000003D9  6A 00	   *	    push   +000000000h
 000003DB  6A 00	   *	    push   +000000000h
 000003DD  6A 10	   *	    push   +000000010h
 000003DF  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000003E2  E8 00000000 E   *	    call   SendMessageA
						.elseif	ax==IDC_ABOUT
 000003E7  EB 6F	   *	    jmp    @C0037
 000003E9		   *@C0035:
 000003E9  66| 83 F8 01	   *	    cmp    ax, IDC_ABOUT
 000003ED  75 1C	   *	    jne    @C0038
							invoke	DialogBoxParam,hinst,addr abtdialog,hwnd,dlgprocabt,0
 000003EF  6A 00	   *	    push   +000000000h
 000003F1  68 00000A45 R   *	    push   dlgprocabt
 000003F6  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000003F9  68 000000BD R   *	    push   OFFSET abtdialog
 000003FE  FF 35 00000000 R *	    push   hinst
 00000404  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_PEVIEW
 00000409  EB 4D	   *	    jmp    @C003A
 0000040B		   *@C0038:
 0000040B  66| 83 F8 02	   *	    cmp    ax, IDC_PEVIEW
 0000040F  75 47	   *	    jne    @C003B
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 00000411  6A 00	   *	    push   +000000000h
 00000413  6A 00	   *	    push   +000000000h
 00000415  6A 10	   *	    push   +000000010h
 00000417  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000041A  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset gendialog,0,addr gendlgproc,0
 0000041F  6A 00	   *	    push   +000000000h
 00000421  68 00000637 R   *	    push   gendlgproc
 00000426  6A 00	   *	    push   +000000000h
 00000428  68 00000048 R   *	    push   dword  ptr OFFSET FLAT:gendialog
 0000042D  FF 35 00000000 R *	    push   hinst
 00000433  E8 00000000 E   *	    call   DialogBoxParamA
						.endif			
					.elseif	uMsg==WM_CLOSE
 00000438  EB 1E	   *	    jmp    @C003D
 0000043A		   *@C0033:
 0000043A  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 0000043E  75 0C	   *	    jne    @C003E
						invoke	EndDialog,hwnd,0
 00000440  6A 00	   *	    push   +000000000h
 00000442  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000445  E8 00000000 E   *	    call   EndDialog
					.else
 0000044A  EB 0C	   *	    jmp    @C0040
 0000044C		   *@C003E:
 0000044C  B8 00000000				mov	eax,FALSE
						ret
 00000451  5B		   *	    pop    ebx
 00000452  5F		   *	    pop    edi
 00000453  5E		   *	    pop    esi
 00000454  C9		   *	    leave  
 00000455  C2 0010	   *	    ret    00010h
					.endif
 00000458		   *@C0040:
 00000458		   *@C003D:
 00000458		   *@C0032:
 00000458		   *@C003B:
 00000458		   *@C003A:
 00000458		   *@C0037:
 00000458  B8 00000001			mov	eax,TRUE
					ret												                   		              
 0000045D  5B		   *	    pop    ebx
 0000045E  5F		   *	    pop    edi
 0000045F  5E		   *	    pop    esi
 00000460  C9		   *	    leave  
 00000461  C2 0010	   *	    ret    00010h
 00000464			pedlgproc	endp	

				;##########################################################

				;##########################################################
 00000464			optdlgproc	proc uses esi edi ebx	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
				local	cbohwnd:HWND
 00000464  55		   *	    push   ebp
 00000465  8B EC	   *	    mov    ebp, esp
 00000467  83 C4 FC	   *	    add    esp, 0FFFFFFFCh
 0000046A  56		   *	    push   esi
 0000046B  57		   *	    push   edi
 0000046C  53		   *	    push   ebx
					.if	uMsg==WM_INITDIALOG
 0000046D  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000474  0F 85 0000011F  *	    jne    @C0041
						invoke	_llseek,rdhwnd,offsets.oh,FILE_BEGIN	
 0000047A  6A 00	   *	    push   +000000000h
 0000047C  FF 35 0000009C R *	    push   dword  ptr offsets+000000014h
 00000482  FF 35 00000014 R *	    push   rdhwnd
 00000488  E8 00000000 E   *	    call   _llseek
						invoke	_lread,rdhwnd,offset ioh,0e0h	
 0000048D  68 000000E0	   *	    push   +0000000E0h
 00000492  68 000000DC R   *	    push   dword  ptr OFFSET FLAT:ioh
 00000497  FF 35 00000014 R *	    push   rdhwnd
 0000049D  E8 00000000 E   *	    call   _lread
						
						invoke	GetDlgItem,hwnd,IDC_IMAGEDATADIRECTORY
 000004A2  6A 6A	   *	    push   +00000006Ah
 000004A4  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000004A7  E8 00000000 E   *	    call   GetDlgItem
 000004AC  89 45 FC				mov	cbohwnd,eax
						
 000004AF  33 C9				xor	ecx,ecx
 000004B1  BA 000000FE R			mov	edx,offset imagedata
						.while	ecx!=15
 000004B6  EB 18	   *	    jmp    @C0043
 000004B8		   *@C0044:
 000004B8  52						push	edx
 000004B9  51						push	ecx
							invoke	SendMessage,cbohwnd,CB_ADDSTRING,0,edx
 000004BA  52		   *	    push   edx
 000004BB  6A 00	   *	    push   +000000000h
 000004BD  68 00000143	   *	    push   +000000143h
 000004C2  FF 75 FC	   *	    push   dword  ptr ss:[ebp]+0FFFFFFFCh
 000004C5  E8 00000000 E   *	    call   SendMessageA
 000004CA  59						pop	ecx
 000004CB  5A						pop	edx
 000004CC  83 C2 15					add	edx,21
 000004CF  41						inc	ecx
						.endw
 000004D0		   *@C0043:
 000004D0  83 F9 0F	   *	    cmp    ecx, 00Fh
 000004D3  75 E3	   *	    jne    @C0044
						
						
						invoke	SetWindowText,hwnd,offset prog
 000004D5  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:prog
 000004DA  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000004DD  E8 00000000 E   *	    call   SetWindowTextA
 000004E2  33 F6				xor	esi,esi
 000004E4  8D 35 000000D7 R			lea	esi,offioh
 000004EA  33 D2				xor	edx,edx
 000004EC  BF 00000073				mov	edi,115
						.while	edi!=145
 000004F1  E9 00000092	   *	    jmp    @C0046
 000004F6		   *@C0047:
 000004F6  52						push	edx
							.if	edi>117 && edi<127 || edi>132 && edi<137 || edi>138
 000004F7  83 FF 75	   *	    cmp    edi, 075h
 000004FA  76 05	   *	    jbe    @C004B
 000004FC  83 FF 7F	   *	    cmp    edi, 07Fh
 000004FF  72 18	   *	    jb     @C0049
 00000501		   *@C004B:
 00000501  81 FF 00000084  *	    cmp    edi, 084h
 00000507  76 08	   *	    jbe    @C004A
 00000509  81 FF 00000089  *	    cmp    edi, 089h
 0000050F  72 08	   *	    jb     @C0049
 00000511		   *@C004A:
 00000511  81 FF 0000008A  *	    cmp    edi, 08Ah
 00000517  76 14	   *	    jbe    @C0048
 00000519		   *@C0049:
								invoke	hexit,dword ptr [ioh+edx],addr buff,8
 00000519  6A 08	   *	    push   +000000008h
 0000051B  68 00000064 R   *	    push   OFFSET buff
 00000520  FF B2 000000DC R *	    push   dword  ptr ioh[edx]
 00000526  E8 0000059C	   *	    call   hexit
							.elseif	edi==115 || edi>126 && edi<133 || edi>136 && edi<139 
 0000052B  EB 48	   *	    jmp    @C004E
 0000052D		   *@C0048:
 0000052D  83 FF 73	   *	    cmp    edi, 073h
 00000530  74 1D	   *	    je     @C0050
 00000532  83 FF 7E	   *	    cmp    edi, 07Eh
 00000535  76 08	   *	    jbe    @C0051
 00000537  81 FF 00000085  *	    cmp    edi, 085h
 0000053D  72 10	   *	    jb     @C0050
 0000053F		   *@C0051:
 0000053F  81 FF 00000088  *	    cmp    edi, 088h
 00000545  76 1C	   *	    jbe    @C004F
 00000547  81 FF 0000008B  *	    cmp    edi, 08Bh
 0000054D  73 14	   *	    jae    @C004F
 0000054F		   *@C0050:
								invoke	hexit,dword ptr [ioh+edx],addr buff,4
 0000054F  6A 04	   *	    push   +000000004h
 00000551  68 00000064 R   *	    push   OFFSET buff
 00000556  FF B2 000000DC R *	    push   dword  ptr ioh[edx]
 0000055C  E8 00000566	   *	    call   hexit
							.else
 00000561  EB 12	   *	    jmp    @C0055
 00000563		   *@C004F:
								invoke	hexit,dword ptr [ioh+edx],addr buff,2
 00000563  6A 02	   *	    push   +000000002h
 00000565  68 00000064 R   *	    push   OFFSET buff
 0000056A  FF B2 000000DC R *	    push   dword  ptr ioh[edx]
 00000570  E8 00000552	   *	    call   hexit
							.endif
							invoke	SetDlgItemText,hwnd,edi,offset buff
 00000575		   *@C0055:
 00000575		   *@C004E:
 00000575  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 0000057A  57		   *	    push   edi
 0000057B  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000057E  E8 00000000 E   *	    call   SetDlgItemTextA
 00000583  5A						pop	edx
 00000584  02 16					add	dl,byte ptr [esi]
 00000586  46						inc	esi
 00000587  47						inc	edi
						.endw
 00000588		   *@C0046:
 00000588  81 FF 00000091  *	    cmp    edi, 091h
 0000058E  0F 85 FFFFFF62  *	    jne    @C0047
						
					.elseif	uMsg==WM_COMMAND
 00000594  E9 00000092	   *	    jmp    @C0057
 00000599		   *@C0041:
 00000599  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 000005A0  75 6B	   *	    jne    @C0058
 000005A2  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK	
 000005A5  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 000005A9  75 10	   *	    jne    @C005A
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000005AB  6A 00	   *	    push   +000000000h
 000005AD  6A 00	   *	    push   +000000000h
 000005AF  6A 10	   *	    push   +000000010h
 000005B1  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000005B4  E8 00000000 E   *	    call   SendMessageA
						.elseif	ax==IDC_ABOUT
 000005B9  EB 70	   *	    jmp    @C005C
 000005BB		   *@C005A:
 000005BB  66| 83 F8 01	   *	    cmp    ax, IDC_ABOUT
 000005BF  75 1C	   *	    jne    @C005D
							invoke	DialogBoxParam,hinst,addr abtdialog,hwnd,dlgprocabt,0
 000005C1  6A 00	   *	    push   +000000000h
 000005C3  68 00000A45 R   *	    push   dlgprocabt
 000005C8  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000005CB  68 000000BD R   *	    push   OFFSET abtdialog
 000005D0  FF 35 00000000 R *	    push   hinst
 000005D6  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_PEVIEW
 000005DB  EB 4E	   *	    jmp    @C005F
 000005DD		   *@C005D:
 000005DD  66| 83 F8 02	   *	    cmp    ax, IDC_PEVIEW
 000005E1  75 48	   *	    jne    @C0060
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000005E3  6A 00	   *	    push   +000000000h
 000005E5  6A 00	   *	    push   +000000000h
 000005E7  6A 10	   *	    push   +000000010h
 000005E9  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000005EC  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,addr gendialog,hwnd,gendlgproc,0
 000005F1  6A 00	   *	    push   +000000000h
 000005F3  68 00000637 R   *	    push   gendlgproc
 000005F8  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000005FB  68 00000048 R   *	    push   OFFSET gendialog
 00000600  FF 35 00000000 R *	    push   hinst
 00000606  E8 00000000 E   *	    call   DialogBoxParamA
						.endif			
					.elseif	uMsg==WM_CLOSE
 0000060B  EB 1E	   *	    jmp    @C0062
 0000060D		   *@C0058:
 0000060D  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 00000611  75 0C	   *	    jne    @C0063
						invoke	EndDialog,hwnd,0
 00000613  6A 00	   *	    push   +000000000h
 00000615  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000618  E8 00000000 E   *	    call   EndDialog
					.else
 0000061D  EB 0C	   *	    jmp    @C0065
 0000061F		   *@C0063:
 0000061F  B8 00000000				mov	eax,FALSE
						ret
 00000624  5B		   *	    pop    ebx
 00000625  5F		   *	    pop    edi
 00000626  5E		   *	    pop    esi
 00000627  C9		   *	    leave  
 00000628  C2 0010	   *	    ret    00010h
					.endif
 0000062B		   *@C0065:
 0000062B		   *@C0062:
 0000062B		   *@C0057:
 0000062B		   *@C0060:
 0000062B		   *@C005F:
 0000062B		   *@C005C:
 0000062B  B8 00000001			mov	eax,TRUE
					ret												                   		              
 00000630  5B		   *	    pop    ebx
 00000631  5F		   *	    pop    edi
 00000632  5E		   *	    pop    esi
 00000633  C9		   *	    leave  
 00000634  C2 0010	   *	    ret    00010h
 00000637			optdlgproc	endp	
				;##########################################################
				;this is the first dialog shown if the file is really pe
				;##########################################################
 00000637			gendlgproc	proc uses esi edi ebx	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 00000637  55		   *	    push   ebp
 00000638  8B EC	   *	    mov    ebp, esp
 0000063A  56		   *	    push   esi
 0000063B  57		   *	    push   edi
 0000063C  53		   *	    push   ebx
					.if	uMsg==WM_INITDIALOG
 0000063D  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000644  0F 85 000000E3  *	    jne    @C0066
						invoke	SetWindowText,hwnd,offset prog
 0000064A  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:prog
 0000064F  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000652  E8 00000000 E   *	    call   SetWindowTextA
						invoke	_llseek,rdhwnd,offlfanew,FILE_BEGIN
 00000657  6A 00	   *	    push   +000000000h
 00000659  6A 3C	   *	    push   +00000003Ch
 0000065B  FF 35 00000014 R *	    push   rdhwnd
 00000661  E8 00000000 E   *	    call   _llseek
						invoke	_lread,rdhwnd,addr offsets.pesign,4
 00000666  6A 04	   *	    push   +000000004h
 00000668  68 00000094 R   *	    push   OFFSET offsets+00000000Ch
 0000066D  FF 35 00000014 R *	    push   rdhwnd
 00000673  E8 00000000 E   *	    call   _lread


				;####################if the file is not pe############
						invoke	_llseek,rdhwnd,offsets.pesign,FILE_BEGIN
 00000678  6A 00	   *	    push   +000000000h
 0000067A  FF 35 00000094 R *	    push   dword  ptr offsets+00000000Ch
 00000680  FF 35 00000014 R *	    push   rdhwnd
 00000686  E8 00000000 E   *	    call   _llseek
						invoke	_lread,rdhwnd,offset pesig,4
 0000068B  6A 04	   *	    push   +000000004h
 0000068D  68 000001EA R   *	    push   dword  ptr OFFSET FLAT:pesig
 00000692  FF 35 00000014 R *	    push   rdhwnd
 00000698  E8 00000000 E   *	    call   _lread
						.if	pesig!=IMAGE_NT_SIGNATURE
 0000069D  81 3D 000001EA R
	   00004550	   *	    cmp    pesig, IMAGE_NT_SIGNATURE
 000006A7  74 27	   *	    je     @C0068
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000006A9  6A 00	   *	    push   +000000000h
 000006AB  6A 00	   *	    push   +000000000h
 000006AD  6A 10	   *	    push   +000000010h
 000006AF  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000006B2  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset dialog,0,addr dlgproc,0
 000006B7  6A 00	   *	    push   +000000000h
 000006B9  68 000001F7 R   *	    push   dlgproc
 000006BE  6A 00	   *	    push   +000000000h
 000006C0  68 0000001B R   *	    push   dword  ptr OFFSET FLAT:dialog
 000006C5  FF 35 00000000 R *	    push   hinst
 000006CB  E8 00000000 E   *	    call   DialogBoxParamA
						.endif
				;##########################################################	
				;		set offsets in offset structure
				;###########################################################

 000006D0		   *@C0068:
 000006D0  A1 00000094 R			mov	eax,offsets.pesign
 000006D5  A3 00000090 R			mov	offsets.pehead,eax
 000006DA  83 C0 04				add	eax,4			;size of pesign
 000006DD  A3 00000098 R			mov	offsets.ifh,eax		;store offset of if header
 000006E2  83 C0 14				add	eax,20			;size of if header
 000006E5  A3 0000009C R			mov	offsets.oh,eax		;store offset of io header
 000006EA  05 000000E0				add	eax,0e0h		;size of io header
 000006EF  A3 000000A0 R			mov	offsets.sect,eax	;store off of section table

				;###########################################################		
						;invoke	SetWindowText,hwnd,offset prog
 000006F4  33 D2				xor	edx,edx
 000006F6  BF 00000073				mov	edi,FIRSTEDIT
						.while	edi!=LASTEDIT
 000006FB  EB 26	   *	    jmp    @C006A
 000006FD		   *@C006B:
 000006FD  52						push	edx
							invoke	hexit,dword ptr [offsets+edx],addr buff,8	;8 signifies digits to convert
 000006FE  6A 08	   *	    push   +000000008h
 00000700  68 00000064 R   *	    push   OFFSET buff
 00000705  FF B2 00000088 R *	    push   dword  ptr offsets[edx]
 0000070B  E8 000003B7	   *	    call   hexit
							invoke	SetDlgItemText,hwnd,edi,offset buff
 00000710  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 00000715  57		   *	    push   edi
 00000716  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000719  E8 00000000 E   *	    call   SetDlgItemTextA
 0000071E  5A						pop	edx
 0000071F  80 C2 04					add	dl,4
 00000722  47						inc	edi
						.endw
 00000723		   *@C006A:
 00000723  83 FF 7C	   *	    cmp    edi, LASTEDIT
 00000726  75 D5	   *	    jne    @C006B
						
					.elseif	uMsg==WM_COMMAND
 00000728  E9 0000012B	   *	    jmp    @C006D
 0000072D		   *@C0066:
 0000072D  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 00000734  0F 85 00000100  *	    jne    @C006E
 0000073A  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK	
 0000073D  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 00000741  75 13	   *	    jne    @C0070
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 00000743  6A 00	   *	    push   +000000000h
 00000745  6A 00	   *	    push   +000000000h
 00000747  6A 10	   *	    push   +000000010h
 00000749  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000074C  E8 00000000 E   *	    call   SendMessageA
						.elseif	ax==IDC_ABOUT
 00000751  E9 00000102	   *	    jmp    @C0072
 00000756		   *@C0070:
 00000756  66| 83 F8 01	   *	    cmp    ax, IDC_ABOUT
 0000075A  75 1F	   *	    jne    @C0073
							invoke	DialogBoxParam,hinst,addr abtdialog,hwnd,dlgprocabt,0
 0000075C  6A 00	   *	    push   +000000000h
 0000075E  68 00000A45 R   *	    push   dlgprocabt
 00000763  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000766  68 000000BD R   *	    push   OFFSET abtdialog
 0000076B  FF 35 00000000 R *	    push   hinst
 00000771  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_DOSHEAD
 00000776  E9 000000DD	   *	    jmp    @C0075
 0000077B		   *@C0073:
 0000077B  66| 83 F8 6F	   *	    cmp    ax, IDC_DOSHEAD
 0000077F  75 2C	   *	    jne    @C0076
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 00000781  6A 00	   *	    push   +000000000h
 00000783  6A 00	   *	    push   +000000000h
 00000785  6A 10	   *	    push   +000000010h
 00000787  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000078A  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset dialog,0,addr dlgproc,0
 0000078F  6A 00	   *	    push   +000000000h
 00000791  68 000001F7 R   *	    push   dlgproc
 00000796  6A 00	   *	    push   +000000000h
 00000798  68 0000001B R   *	    push   dword  ptr OFFSET FLAT:dialog
 0000079D  FF 35 00000000 R *	    push   hinst
 000007A3  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_SECTION
 000007A8  E9 000000AB	   *	    jmp    @C0078
 000007AD		   *@C0076:
 000007AD  66| 83 F8 70	   *	    cmp    ax, IDC_SECTION
 000007B1  75 29	   *	    jne    @C0079
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000007B3  6A 00	   *	    push   +000000000h
 000007B5  6A 00	   *	    push   +000000000h
 000007B7  6A 10	   *	    push   +000000010h
 000007B9  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000007BC  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset secdialog,0,addr secdlgproc,0
 000007C1  6A 00	   *	    push   +000000000h
 000007C3  68 00000864 R   *	    push   secdlgproc
 000007C8  6A 00	   *	    push   +000000000h
 000007CA  68 0000003C R   *	    push   dword  ptr OFFSET FLAT:secdialog
 000007CF  FF 35 00000000 R *	    push   hinst
 000007D5  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_IFH
 000007DA  EB 7C	   *	    jmp    @C007B
 000007DC		   *@C0079:
 000007DC  66| 83 F8 7D	   *	    cmp    ax, IDC_IFH
 000007E0  75 29	   *	    jne    @C007C
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000007E2  6A 00	   *	    push   +000000000h
 000007E4  6A 00	   *	    push   +000000000h
 000007E6  6A 10	   *	    push   +000000010h
 000007E8  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000007EB  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset pedialog,0,addr pedlgproc,0
 000007F0  6A 00	   *	    push   +000000000h
 000007F2  68 00000356 R   *	    push   pedlgproc
 000007F7  6A 00	   *	    push   +000000000h
 000007F9  68 00000023 R   *	    push   dword  ptr OFFSET FLAT:pedialog
 000007FE  FF 35 00000000 R *	    push   hinst
 00000804  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_OPTION
 00000809  EB 4D	   *	    jmp    @C007E
 0000080B		   *@C007C:
 0000080B  66| 83 F8 71	   *	    cmp    ax, IDC_OPTION
 0000080F  75 47	   *	    jne    @C007F
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 00000811  6A 00	   *	    push   +000000000h
 00000813  6A 00	   *	    push   +000000000h
 00000815  6A 10	   *	    push   +000000010h
 00000817  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000081A  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset optdialog,0,addr optdlgproc,0
 0000081F  6A 00	   *	    push   +000000000h
 00000821  68 00000464 R   *	    push   optdlgproc
 00000826  6A 00	   *	    push   +000000000h
 00000828  68 0000002E R   *	    push   dword  ptr OFFSET FLAT:optdialog
 0000082D  FF 35 00000000 R *	    push   hinst
 00000833  E8 00000000 E   *	    call   DialogBoxParamA
						.endif			
					
					.elseif	uMsg==WM_CLOSE
 00000838  EB 1E	   *	    jmp    @C0081
 0000083A		   *@C006E:
 0000083A  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 0000083E  75 0C	   *	    jne    @C0082
						invoke	EndDialog,hwnd,0
 00000840  6A 00	   *	    push   +000000000h
 00000842  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000845  E8 00000000 E   *	    call   EndDialog
					.else
 0000084A  EB 0C	   *	    jmp    @C0084
 0000084C		   *@C0082:
 0000084C  B8 00000000				mov	eax,FALSE
						ret
 00000851  5B		   *	    pop    ebx
 00000852  5F		   *	    pop    edi
 00000853  5E		   *	    pop    esi
 00000854  C9		   *	    leave  
 00000855  C2 0010	   *	    ret    00010h
					.endif
 00000858		   *@C0084:
 00000858		   *@C0081:
 00000858		   *@C006D:
 00000858		   *@C007F:
 00000858		   *@C007E:
 00000858		   *@C007B:
 00000858		   *@C0078:
 00000858		   *@C0075:
 00000858		   *@C0072:
 00000858  B8 00000001			mov	eax,TRUE
					ret												                   		              
 0000085D  5B		   *	    pop    ebx
 0000085E  5F		   *	    pop    edi
 0000085F  5E		   *	    pop    esi
 00000860  C9		   *	    leave  
 00000861  C2 0010	   *	    ret    00010h
 00000864			gendlgproc	endp	
				;##########################################################

				;##########################################################
 00000864			secdlgproc	proc uses esi edi ebx	hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 00000864  55		   *	    push   ebp
 00000865  8B EC	   *	    mov    ebp, esp
 00000867  56		   *	    push   esi
 00000868  57		   *	    push   edi
 00000869  53		   *	    push   ebx
					.if	uMsg==WM_INITDIALOG
 0000086A  81 7D 0C
	   00000110	   *	    cmp    uMsg, WM_INITDIALOG
 00000871  0F 85 00000131  *	    jne    @C0085
						invoke	SetWindowText,hwnd,offset prog
 00000877  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:prog
 0000087C  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 0000087F  E8 00000000 E   *	    call   SetWindowTextA
 00000884  A1 00000098 R			mov	eax,offsets.ifh
 00000889  83 C0 02				add	eax,2
						invoke	_llseek,rdhwnd,eax,FILE_BEGIN
 0000088C  6A 00	   *	    push   +000000000h
 0000088E  50		   *	    push   eax
 0000088F  FF 35 00000014 R *	    push   rdhwnd
 00000895  E8 00000000 E   *	    call   _llseek
						invoke	_lread,rdhwnd,offset sections,2		;read no of sections
 0000089A  6A 02	   *	    push   +000000002h
 0000089C  68 000001E4 R   *	    push   dword  ptr OFFSET FLAT:sections
 000008A1  FF 35 00000014 R *	    push   rdhwnd
 000008A7  E8 00000000 E   *	    call   _lread
						;.if	section==2
							;invoke	SetWindowPos,hwnd,HWND_TOP,
						
						invoke	_llseek,rdhwnd,offsets.sect,FILE_BEGIN
 000008AC  6A 00	   *	    push   +000000000h
 000008AE  FF 35 000000A0 R *	    push   dword  ptr offsets+000000018h
 000008B4  FF 35 00000014 R *	    push   rdhwnd
 000008BA  E8 00000000 E   *	    call   _llseek
 000008BF  BF 00000074				mov	edi,116
 000008C4  C7 05 00000078 R			mov	zero,115
	   00000073
 000008CE  C7 05 0000007C R			mov	first,126
	   0000007E
 000008D8  C7 05 00000080 R			mov	second,122
	   0000007A
 000008E2  C7 05 00000084 R			mov	third,124
	   0000007C
						
						.while	sections!=0
 000008EC  E9 000000A4	   *	    jmp    @C0087
 000008F1		   *@C0088:
							invoke	_lread,rdhwnd,offset ish,28h	;ish=40bytes
 000008F1  6A 28	   *	    push   +000000028h
 000008F3  68 000001BC R   *	    push   dword  ptr OFFSET FLAT:ish
 000008F8  FF 35 00000014 R *	    push   rdhwnd
 000008FE  E8 00000000 E   *	    call   _lread
							invoke	SetDlgItemText,hwnd,zero,offset ish
 00000903  68 000001BC R   *	    push   dword  ptr OFFSET FLAT:ish
 00000908  FF 35 00000078 R *	    push   zero
 0000090E  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000911  E8 00000000 E   *	    call   SetDlgItemTextA
					
 00000916  8D 35 000000F5 R				lea	esi,offish
 0000091C  33 D2					xor	edx,edx	
							.while	edi!=first
 0000091E  EB 4A	   *	    jmp    @C0089
 00000920		   *@C008A:
 00000920  52							push	edx
								.if	edi<second || edi==third
 00000921  3B 3D 00000080 R *	    cmp    edi, second
 00000927  72 08	   *	    jb     @C008C
 00000929  3B 3D 00000084 R *	    cmp    edi, third
 0000092F  75 14	   *	    jne    @C008B
 00000931		   *@C008C:
									invoke	hexit,dword ptr [ish+edx+8],addr buff,8
 00000931  6A 08	   *	    push   +000000008h
 00000933  68 00000064 R   *	    push   OFFSET buff
 00000938  FF B2 000001C4 R *	    push   dword  ptr ish[edx]+000000008h
 0000093E  E8 00000184	   *	    call   hexit
								.else
 00000943  EB 12	   *	    jmp    @C008E
 00000945		   *@C008B:
									invoke	hexit,dword ptr [ish+edx+8],addr buff,4
 00000945  6A 04	   *	    push   +000000004h
 00000947  68 00000064 R   *	    push   OFFSET buff
 0000094C  FF B2 000001C4 R *	    push   dword  ptr ish[edx]+000000008h
 00000952  E8 00000170	   *	    call   hexit
								.endif
								invoke	SetDlgItemText,hwnd,edi,offset buff
 00000957		   *@C008E:
 00000957  68 00000064 R   *	    push   dword  ptr OFFSET FLAT:buff
 0000095C  57		   *	    push   edi
 0000095D  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000960  E8 00000000 E   *	    call   SetDlgItemTextA
 00000965  5A							pop	edx
 00000966  02 16						add	dl,byte ptr [esi]
 00000968  46							inc	esi
 00000969  47							inc	edi
							.endw
 0000096A		   *@C0089:
 0000096A  3B 3D 0000007C R *	    cmp    edi, first
 00000970  75 AE	   *	    jne    @C008A
 00000972  66| FF 0D					dec	sections
	   000001E4 R
 00000979  83 05 00000078 R				add	zero,10
	   0A
 00000980  83 05 0000007C R				add	first,10
	   0A
 00000987  83 05 00000080 R				add	second,10
	   0A
 0000098E  83 05 00000084 R				add	third,10
	   0A
						.endw
 00000995		   *@C0087:
 00000995  66| 83 3D
	   000001E4 R 00   *	    cmp    sections, 000h
 0000099D  0F 85 FFFFFF4E  *	    jne    @C0088
					
					.elseif	uMsg==WM_COMMAND
 000009A3  E9 00000091	   *	    jmp    @C0091
 000009A8		   *@C0085:
 000009A8  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 000009AF  75 6A	   *	    jne    @C0092
 000009B1  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK	
 000009B4  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 000009B8  75 10	   *	    jne    @C0094
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000009BA  6A 00	   *	    push   +000000000h
 000009BC  6A 00	   *	    push   +000000000h
 000009BE  6A 10	   *	    push   +000000010h
 000009C0  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000009C3  E8 00000000 E   *	    call   SendMessageA
						.elseif	ax==IDC_ABOUT
 000009C8  EB 6F	   *	    jmp    @C0096
 000009CA		   *@C0094:
 000009CA  66| 83 F8 01	   *	    cmp    ax, IDC_ABOUT
 000009CE  75 1C	   *	    jne    @C0097
							invoke	DialogBoxParam,hinst,addr abtdialog,hwnd,dlgprocabt,0
 000009D0  6A 00	   *	    push   +000000000h
 000009D2  68 00000A45 R   *	    push   dlgprocabt
 000009D7  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000009DA  68 000000BD R   *	    push   OFFSET abtdialog
 000009DF  FF 35 00000000 R *	    push   hinst
 000009E5  E8 00000000 E   *	    call   DialogBoxParamA
						.elseif	ax==IDC_PEVIEW
 000009EA  EB 4D	   *	    jmp    @C0099
 000009EC		   *@C0097:
 000009EC  66| 83 F8 02	   *	    cmp    ax, IDC_PEVIEW
 000009F0  75 47	   *	    jne    @C009A
							invoke	SendMessage,hwnd,WM_CLOSE,0,0
 000009F2  6A 00	   *	    push   +000000000h
 000009F4  6A 00	   *	    push   +000000000h
 000009F6  6A 10	   *	    push   +000000010h
 000009F8  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000009FB  E8 00000000 E   *	    call   SendMessageA
							invoke	DialogBoxParam,hinst,offset gendialog,0,addr gendlgproc,0
 00000A00  6A 00	   *	    push   +000000000h
 00000A02  68 00000637 R   *	    push   gendlgproc
 00000A07  6A 00	   *	    push   +000000000h
 00000A09  68 00000048 R   *	    push   dword  ptr OFFSET FLAT:gendialog
 00000A0E  FF 35 00000000 R *	    push   hinst
 00000A14  E8 00000000 E   *	    call   DialogBoxParamA
						.endif			
					.elseif	uMsg==WM_CLOSE
 00000A19  EB 1E	   *	    jmp    @C009C
 00000A1B		   *@C0092:
 00000A1B  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 00000A1F  75 0C	   *	    jne    @C009D
						invoke	EndDialog,hwnd,0
 00000A21  6A 00	   *	    push   +000000000h
 00000A23  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000A26  E8 00000000 E   *	    call   EndDialog
					.else
 00000A2B  EB 0C	   *	    jmp    @C009F
 00000A2D		   *@C009D:
 00000A2D  B8 00000000				mov	eax,FALSE
						ret
 00000A32  5B		   *	    pop    ebx
 00000A33  5F		   *	    pop    edi
 00000A34  5E		   *	    pop    esi
 00000A35  C9		   *	    leave  
 00000A36  C2 0010	   *	    ret    00010h
					.endif
 00000A39		   *@C009F:
 00000A39		   *@C009C:
 00000A39		   *@C0091:
 00000A39		   *@C009A:
 00000A39		   *@C0099:
 00000A39		   *@C0096:
 00000A39  B8 00000001			mov	eax,TRUE
					ret												                   		              
 00000A3E  5B		   *	    pop    ebx
 00000A3F  5F		   *	    pop    edi
 00000A40  5E		   *	    pop    esi
 00000A41  C9		   *	    leave  
 00000A42  C2 0010	   *	    ret    00010h
 00000A45			secdlgproc	endp	
				;##########################################################

				;##########################################################
					
 00000A45			dlgprocabt proc hwnd:HWND,uMsg:UINT,wparam:WPARAM,lparam:LPARAM
 00000A45  55		   *	    push   ebp
 00000A46  8B EC	   *	    mov    ebp, esp
					.if uMsg==WM_COMMAND
 00000A48  81 7D 0C
	   00000111	   *	    cmp    uMsg, WM_COMMAND
 00000A4F  75 15	   *	    jne    @C00A0
 00000A51  8B 45 10				mov	eax,wparam
						.if	ax==IDC_OK
 00000A54  66| 83 F8 66	   *	    cmp    ax, IDC_OK
 00000A58  75 27	   *	    jne    @C00A2
							invoke	EndDialog,hwnd,0
 00000A5A  6A 00	   *	    push   +000000000h
 00000A5C  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000A5F  E8 00000000 E   *	    call   EndDialog
						.endif
					.elseif	uMsg==WM_CLOSE
 00000A64  EB 1B	   *	    jmp    @C00A4
 00000A66		   *@C00A0:
 00000A66  83 7D 0C 10	   *	    cmp    uMsg, WM_CLOSE
 00000A6A  75 0C	   *	    jne    @C00A5
						invoke	EndDialog,hwnd,0
 00000A6C  6A 00	   *	    push   +000000000h
 00000A6E  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 00000A71  E8 00000000 E   *	    call   EndDialog
					.else
 00000A76  EB 09	   *	    jmp    @C00A7
 00000A78		   *@C00A5:
 00000A78  B8 00000000				mov	eax,FALSE
						ret
 00000A7D  C9		   *	    leave  
 00000A7E  C2 0010	   *	    ret    00010h
					.endif
 00000A81		   *@C00A7:
 00000A81		   *@C00A4:
 00000A81		   *@C00A2:
 00000A81  B8 00000001			mov	eax,TRUE
					ret
 00000A86  C9		   *	    leave  
 00000A87  C2 0010	   *	    ret    00010h
 00000A8A			dlgprocabt	endp				
				;##########################################################

				;##########################################################	
						
 00000A8A			getprog	proc uses ebx esi edi
 00000A8A  53		   *	    push   ebx
 00000A8B  56		   *	    push   esi
 00000A8C  57		   *	    push   edi
 00000A8D  33 FF			xor	edi,edi
 00000A8F  A1 00000004 R		mov	eax,cmdline
					.while	byte ptr [eax]!=20h
 00000A94  EB 0A	   *	    jmp    @C00A8
 00000A96		   *@C00A9:
						.break .if edi==200h
 00000A96  81 FF 00000200  *	    cmp    edi, 00200h
 00000A9C  74 07	   *	    je     @C00AA
 00000A9E  40					inc	eax
 00000A9F  47					inc	edi
					.endw
 00000AA0		   *@C00A8:
 00000AA0  80 38 20	   *	    cmp    byte ptr [eax], 020h
 00000AA3  75 F1	   *	    jne    @C00A9
 00000AA5		   *@C00AA:
					
 00000AA5  33 F6			xor	esi,esi
 00000AA7  33 FF			xor	edi,edi
					.while	byte ptr [eax]!=0
 00000AA9  EB 13	   *	    jmp    @C00AD
 00000AAB		   *@C00AE:
						.break  .if edi==200h
 00000AAB  81 FF 00000200  *	    cmp    edi, 00200h
 00000AB1  74 10	   *	    je     @C00AF
 00000AB3  47					inc	edi
 00000AB4  8A 08				mov	cl,byte ptr [eax]
 00000AB6  88 8E 00000000 R			mov	[prog+esi],cl
 00000ABC  46					inc	esi
 00000ABD  40					inc	eax
					.endw
 00000ABE		   *@C00AD:
 00000ABE  80 38 00	   *	    cmp    byte ptr [eax], 000h
 00000AC1  75 E8	   *	    jne    @C00AE
 00000AC3		   *@C00AF:
						
					ret
 00000AC3  5F		   *	    pop    edi
 00000AC4  5E		   *	    pop    esi
 00000AC5  5B		   *	    pop    ebx
 00000AC6  C3		   *	    ret    00000h
 00000AC7			getprog	endp		
					
				;##########################################################

				;##########################################################
 00000AC7			hexit	proc uses ebx esi edi num:dword,pntr:dword,count:dword
 00000AC7  55		   *	    push   ebp
 00000AC8  8B EC	   *	    mov    ebp, esp
 00000ACA  53		   *	    push   ebx
 00000ACB  56		   *	    push   esi
 00000ACC  57		   *	    push   edi
 00000ACD  8B 45 08			mov	eax,num
 00000AD0  66| 33 DB			xor	bx,bx
 00000AD3  33 D2			xor	edx,edx
 00000AD5  33 DB			xor	ebx,ebx
 00000AD7  B3 10			mov	bl,10h
 00000AD9  33 F6			xor	esi,esi
 00000ADB  8B 4D 0C			mov	ecx,pntr
					.while	esi!=count
 00000ADE  EB 06	   *	    jmp    @C00B2
 00000AE0		   *@C00B3:
 00000AE0  33 D2				xor	edx,edx
 00000AE2  F7 F3				div	ebx
 00000AE4  46					inc	esi
 00000AE5  52					push	edx
					.endw	
 00000AE6		   *@C00B2:
 00000AE6  3B 75 10	   *	    cmp    esi, count
 00000AE9  75 F5	   *	    jne    @C00B3
					
 00000AEB  33 FF			xor	edi,edi
					
					.while	esi!=0
 00000AED  EB 16	   *	    jmp    @C00B5
 00000AEF		   *@C00B6:
 00000AEF  5A					pop	edx
 00000AF0  4E					dec	esi
						.if	dx>9
 00000AF1  66| 83 FA 09	   *	    cmp    dx, 009h
 00000AF5  76 06	   *	    jbe    @C00B7
 00000AF7  66| 83 C2 37					add	dx,37h
						.else
 00000AFB  EB 04	   *	    jmp    @C00B9
 00000AFD		   *@C00B7:
 00000AFD  66| 83 C2 30					add	dx,30h
						.endif
				;		mov	byte ptr [pntr+edi],dl	;imp this wont work, herre pntr is not treated as pointer
 00000B01		   *@C00B9:
 00000B01  88 14 0F				mov	[ecx+edi],dl
 00000B04  47					inc	edi
					.endw
 00000B05		   *@C00B5:
 00000B05  0B F6	   *	    or	esi, esi
 00000B07  75 E6	   *	    jne    @C00B6
 00000B09  C6 04 0F 00			mov	byte ptr [ecx+edi],0
					ret	
 00000B0D  5F		   *	    pop    edi
 00000B0E  5E		   *	    pop    esi
 00000B0F  5B		   *	    pop    ebx
 00000B10  C9		   *	    leave  
 00000B11  C2 000C	   *	    ret    0000Ch
 00000B14			hexit	endp	
				end	start
				;##########################################################

Microsoft (R) Macro Assembler Version 6.14.8444		    01/04/04 23:22:22
F:\programs\WIN32ASM\console\pemap.asm			     Page 1 - 1


				;WIN32 CONSOLE PROGRAM
				.386
				.model flat, stdcall

				option casemap:none
				.nolist
				.listall
				includelib kernel32.lib
				includelib user32.lib
				includelib crtlib.lib
				includelib masm32.lib
				hexit	proto  num:dword,pntr:dword,count:dword
				printbyte proto base:dword, loc1:dword,loc2:dword

				main proto stdcall :dword, :dword
 00000000			.data
 00000000 20 00			space	db	20h,0
 00000002 0A 0D 00		crlf	db	10,13,0
 = 00000020			len	equ	32
				;header	IMAGE_NT_HEADER  <0>
 00000000			.data?
 00000000  00000032 [		buffer	db	50 dup(?)
	    00
	   ]
 00000032 00000000		fmap	dd	?
 00000036 00000000		map	dd	?
 0000003A 00			fopen	db	?	;flag whether file is opened
 0000003B 00000000		rdhwnd	dd	?
				closfile	macro
					invoke 	UnmapViewOfFile,map 
					invoke	CloseHandle,fmap
					invoke	CloseHandle,rdhwnd
				endm
 00000000			.const
 00000000 50 45 20 4D 61	logo	db	"PE Mapper - written by Madhur",10,13
	   70 70 65 72 20
	   2D 20 77 72 69
	   74 74 65 6E 20
	   62 79 20 4D 61
	   64 68 75 72 0A
	   0D
 0000001F  55 73 61 67 65		db	"Usage: pemap [filename]",0
	   3A 20 70 65 6D
	   61 70 20 5B 66
	   69 6C 65 6E 61
	   6D 65 5D 00
					
 00000037 45 72 72 6F 72	err1	db	"Error Opening File",0
	   20 4F 70 65 6E
	   69 6E 67 20 46
	   69 6C 65 00
 0000004A 55 6E 61 62 6C	err2	db	"Unable to Map file into memory",0
	   65 20 74 6F 20
	   4D 61 70 20 66
	   69 6C 65 20 69
	   6E 74 6F 20 6D
	   65 6D 6F 72 79
	   00
 00000069 4D 65 6D 6F 72	err3	db	"Memory Map error",0
	   79 20 4D 61 70
	   20 65 72 72 6F
	   72 00
 0000007A 54 68 65 20 66	err4	db	"The file is not a valid Portable Executable File",0
	   69 6C 65 20 69
	   73 20 6E 6F 74
	   20 61 20 76 61
	   6C 69 64 20 50
	   6F 72 74 61 62
	   6C 65 20 45 78
	   65 63 75 74 61
	   62 6C 65 20 46
	   69 6C 65 00
 000000AB 54 68 65 20 73	err5	db	"The specified memory address is not a valid address",0
	   70 65 63 69 66
	   69 65 64 20 6D
	   65 6D 6F 72 79
	   20 61 64 64 72
	   65 73 73 20 69
	   73 20 6E 6F 74
	   20 61 20 76 61
	   6C 69 64 20 61
	   64 64 72 65 73
	   73 00
 000000DF 54 68 65 20 73	err6	db	"The specified address was not found in the file",13,10
	   70 65 63 69 66
	   69 65 64 20 61
	   64 64 72 65 73
	   73 20 77 61 73
	   20 6E 6F 74 20
	   66 6F 75 6E 64
	   20 69 6E 20 74
	   68 65 20 66 69
	   6C 65 0D 0A
 00000110  4D 6F 73 74 20		db	"Most likely,it falls in the section gaps",0
	   6C 69 6B 65 6C
	   79 2C 69 74 20
	   66 61 6C 6C 73
	   20 69 6E 20 74
	   68 65 20 73 65
	   63 74 69 6F 6E
	   20 67 61 70 73
	   00
 00000139 30 00			null	db	"0",0
				printhex proto num:dword
 00000000			.code
				;   startup code
 00000000			start:
 00000000  83 EC 0C		    sub     esp, 12
 00000003  8D 04 24		    lea     eax, [esp+0]    ; &env
 00000006  8D 4C 24 04		    lea     ecx, [esp+4]    ; &argc
 0000000A  8D 54 24 08		    lea     edx, [esp+8]    ; &argv
				    invoke  getmainargs, ecx, edx, eax, 0	;this call will put the env,argc,argv on stack,doesnt removes argument
 0000000E  6A 00	   *	    push   +000000000h
 00000010  50		   *	    push   eax
 00000011  52		   *	    push   edx
 00000012  51		   *	    push   ecx
 00000013  E8 00000000 E   *	    call   __GetMainArgs
 00000018  83 C4 10	   *	    add    esp, 000000010h
 0000001B  83 C4 04		    add     esp, 4          ; remove env (not used)
 0000001E  E8 00000006		    call    main
				    invoke  ExitProcess, eax
 00000023  50		   *	    push   eax
 00000024  E8 00000000 E   *	    call   ExitProcess

 00000029 00000029		main proc argc:dword, argv:dword
				local file:dword	
				local imagebase:dword
				local peoff:dword


				;check whether structure of program is good	
 00000029  55		   *	    push   ebp
 0000002A  8B EC	   *	    mov    ebp, esp
 0000002C  83 C4 F4	   *	    add    esp, 0FFFFFFF4h
 0000002F  8B 45 08			mov	eax,argc
					.if	eax==1
 00000032  83 F8 01	   *	    cmp    eax, 001h
 00000035  75 11	   *	    jne    @C0001
						invoke	StdOut,offset logo
 00000037  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:logo
 0000003C  E8 00000000 E   *	    call   StdOut
						invoke	ExitProcess,0
 00000041  6A 00	   *	    push   +000000000h
 00000043  E8 00000000 E   *	    call   ExitProcess
					.endif
 00000048		   *@C0001:
 00000048  8B 4D 0C			mov	ecx,argv	;mov ecx,argv+4 won't work , discover why
 0000004B  83 C1 04			add	ecx,4
					
					invoke	CreateFile,[ecx],GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0
 0000004E  6A 00	   *	    push   +000000000h
 00000050  68 00000080	   *	    push   +000000080h
 00000055  6A 03	   *	    push   +000000003h
 00000057  6A 00	   *	    push   +000000000h
 00000059  6A 01	   *	    push   +000000001h
 0000005B  68 80000000	   *	    push   +080000000h
 00000060  FF 31	   *	    push   dword  ptr [ecx]
 00000062  E8 00000000 E   *	    call   CreateFileA
					.if	eax==INVALID_HANDLE_VALUE
 00000067  83 F8 FF	   *	    cmp    eax, INVALID_HANDLE_VALUE
 0000006A  75 0E	   *	    jne    @C0003
						invoke	StdOut,offset err1
 0000006C  68 00000037 R   *	    push   dword  ptr OFFSET FLAT:err1
 00000071  E8 00000000 E   *	    call   StdOut
						ret
 00000076  C9		   *	    leave  
 00000077  C2 0008	   *	    ret    00008h
					.endif
 0000007A		   *@C0003:
 0000007A  A3 0000003B R		mov	rdhwnd,eax
					invoke	CreateFileMapping,rdhwnd,0,PAGE_READONLY,0,0,0
 0000007F  6A 00	   *	    push   +000000000h
 00000081  6A 00	   *	    push   +000000000h
 00000083  6A 00	   *	    push   +000000000h
 00000085  6A 02	   *	    push   +000000002h
 00000087  6A 00	   *	    push   +000000000h
 00000089  FF 35 0000003B R *	    push   rdhwnd
 0000008F  E8 00000000 E   *	    call   CreateFileMappingA
					.if	eax==0
 00000094  0B C0	   *	    or	eax, eax
 00000096  75 0F	   *	    jne    @C0005
						invoke	StdOut,offset err2
 00000098  68 0000004A R   *	    push   dword  ptr OFFSET FLAT:err2
 0000009D  E8 00000000 E   *	    call   StdOut
 000000A2  E9 000000DA				jmp	ret1
					.endif
 000000A7		   *@C0005:
 000000A7  A3 00000032 R		mov	fmap,eax
					invoke	MapViewOfFile,fmap,FILE_MAP_READ,0,0,0
 000000AC  6A 00	   *	    push   +000000000h
 000000AE  6A 00	   *	    push   +000000000h
 000000B0  6A 00	   *	    push   +000000000h
 000000B2  6A 04	   *	    push   +000000004h
 000000B4  FF 35 00000032 R *	    push   fmap
 000000BA  E8 00000000 E   *	    call   MapViewOfFile
					.if	eax==0
 000000BF  0B C0	   *	    or	eax, eax
 000000C1  75 0F	   *	    jne    @C0007
						invoke	StdOut,offset err2
 000000C3  68 0000004A R   *	    push   dword  ptr OFFSET FLAT:err2
 000000C8  E8 00000000 E   *	    call   StdOut
 000000CD  E9 000000AF				jmp	ret1
					.endif
 000000D2		   *@C0007:
									
 000000D2  A3 00000036 R		mov	map,eax
 000000D7  8B 3D 00000036 R		mov	edi,map
					assume edi:ptr IMAGE_DOS_HEADER 
				       .if [edi].e_magic==IMAGE_DOS_SIGNATURE 
 000000DD  66| 81 3F 5A4D  *	    cmp    [edi] . e_magic, IMAGE_DOS_SIGNATURE
 000000E2  75 3F	   *	    jne    @C0009
 000000E4  33 C0		       		xor	eax,eax
 000000E6  66| 8B 47 3C		                mov	ax,word ptr [edi].e_lfanew
 000000EA  03 F8		                add 	edi,eax
				                assume edi:ptr IMAGE_NT_HEADERS 
				                .if [edi].Signature==IMAGE_NT_SIGNATURE 
 000000EC  81 3F 00004550  *	    cmp    [edi] . Signature, IMAGE_NT_SIGNATURE
 000000F2  75 02	   *	    jne    @C000B
				                .else 
 000000F4  EB 58	   *	    jmp    @C000D
 000000F6		   *@C000B:
				                	invoke	StdOut,offset err4
 000000F6  68 0000007A R   *	    push   dword  ptr OFFSET FLAT:err4
 000000FB  E8 00000000 E   *	    call   StdOut
				                 	closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000100  FF 35 00000036 R *	    push   map
 00000106  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 0000010B  FF 35 00000032 R *	    push   fmap
 00000111  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 00000116  FF 35 0000003B R *	    push   rdhwnd
 0000011C  E8 00000000 E   *	    call   CloseHandle
				                .endif 
				         .else 
 00000121  EB 2B	   *	    jmp    @C000E
 00000123		   *@C0009:
				         	invoke	StdOut,offset err4
 00000123  68 0000007A R   *	    push   dword  ptr OFFSET FLAT:err4
 00000128  E8 00000000 E   *	    call   StdOut
				         	closfile
			     1		invoke 	UnmapViewOfFile,map 
 0000012D  FF 35 00000036 R *	    push   map
 00000133  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 00000138  FF 35 00000032 R *	    push   fmap
 0000013E  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 00000143  FF 35 0000003B R *	    push   rdhwnd
 00000149  E8 00000000 E   *	    call   CloseHandle
				         .endif 
 0000014E		   *@C000E:
 0000014E		   *@C000D:
					
 0000014E  8B 0D 00000036 R		mov	ecx,map
					assume	ecx:PTR IMAGE_DOS_HEADER
 00000154  03 49 3C			add	ecx,[ecx].e_lfanew
					m2m	peoff,[ecx].e_lfanew			
 00000157  FF 71 3C	     1		push	[ecx].e_lfanew
 0000015A  8F 45 F4	     1		pop	peoff
					assume	ecx:PTR IMAGE_NT_HEADERS
					m2m	imagebase,[ecx].OptionalHeader.ImageBase
 0000015D  FF 71 34	     1		push	[ecx].OptionalHeader.ImageBase
 00000160  8F 45 F8	     1		pop	imagebase
					;invoke	printhex,imagebase
					
 00000163  8B 0D 00000036 R		mov	ecx,map
 00000169  81 C1 00000400		add	ecx,400h
 0000016F  8B D1			mov	edx,ecx
 00000171  81 C2 00000400		add	edx,400h
					invoke	printbyte,imagebase,ecx,edx
 00000177  52		   *	    push   edx
 00000178  51		   *	    push   ecx
 00000179  FF 75 F8	   *	    push   dword  ptr ss:[ebp]+0FFFFFFF8h
 0000017C  E8 00000050	   *	    call   printbyte

 00000181			ret1:
					closfile
			     1		invoke 	UnmapViewOfFile,map 
 00000181  FF 35 00000036 R *	    push   map
 00000187  E8 00000000 E   *	    call   UnmapViewOfFile
			     1		invoke	CloseHandle,fmap
 0000018C  FF 35 00000032 R *	    push   fmap
 00000192  E8 00000000 E   *	    call   CloseHandle
			     1		invoke	CloseHandle,rdhwnd
 00000197  FF 35 0000003B R *	    push   rdhwnd
 0000019D  E8 00000000 E   *	    call   CloseHandle
					ret
 000001A2  C9		   *	    leave  
 000001A3  C2 0008	   *	    ret    00008h
 000001A6			main endp


 000001A6			printhex proc uses eax ebx ecx edx esi edi num:dword
				local buff[10]:byte
 000001A6  55		   *	    push   ebp
 000001A7  8B EC	   *	    mov    ebp, esp
 000001A9  83 C4 F4	   *	    add    esp, 0FFFFFFF4h
 000001AC  50		   *	    push   eax
 000001AD  53		   *	    push   ebx
 000001AE  51		   *	    push   ecx
 000001AF  52		   *	    push   edx
 000001B0  56		   *	    push   esi
 000001B1  57		   *	    push   edi
					invoke	dw2hex,num,addr buff
 000001B2  8D 45 F6	   *	    lea    eax, byte  ptr ss:[ebp]+0F6h
 000001B5  50		   *	    push   eax
 000001B6  FF 75 08	   *	    push   dword  ptr ss:[ebp]+000000008h
 000001B9  E8 00000000 E   *	    call   dw2hex
					invoke 	StdOut,addr buff
 000001BE  8D 45 F6	   *	    lea    eax, byte  ptr ss:[ebp]+0F6h
 000001C1  50		   *	    push   eax
 000001C2  E8 00000000 E   *	    call   StdOut
					ret
 000001C7  5F		   *	    pop    edi
 000001C8  5E		   *	    pop    esi
 000001C9  5A		   *	    pop    edx
 000001CA  59		   *	    pop    ecx
 000001CB  5B		   *	    pop    ebx
 000001CC  58		   *	    pop    eax
 000001CD  C9		   *	    leave  
 000001CE  C2 0004	   *	    ret    00004h
 000001D1			printhex endp


 000001D1			printbyte proc uses eax ebx ecx edx esi edi base:dword, loc1:dword,loc2:dword
				local buff[10]:byte
 000001D1  55		   *	    push   ebp
 000001D2  8B EC	   *	    mov    ebp, esp
 000001D4  83 C4 F4	   *	    add    esp, 0FFFFFFF4h
 000001D7  50		   *	    push   eax
 000001D8  53		   *	    push   ebx
 000001D9  51		   *	    push   ecx
 000001DA  52		   *	    push   edx
 000001DB  56		   *	    push   esi
 000001DC  57		   *	    push   edi
 000001DD  83 45 10 20			add	loc2,len
 000001E1  8B 75 0C			mov	esi,loc1
 000001E4  8B 5D 08			mov	ebx,base
					.while	esi!=loc2
 000001E7  EB 50	   *	    jmp    @C000F
 000001E9		   *@C0010:
						invoke	printhex,ebx
 000001E9  53		   *	    push   ebx
 000001EA  E8 FFFFFFB7	   *	    call   printhex
						invoke	StdOut,offset space
 000001EF  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:space
 000001F4  E8 00000000 E   *	    call   StdOut
 000001F9  33 FF				xor	edi,edi
 000001FB  33 D2				xor	edx,edx
						.while	esi!=loc2 && edi!=len
 000001FD  EB 23	   *	    jmp    @C0011
 000001FF		   *@C0012:
 000001FF  8A 16					mov	dl,byte ptr [esi]
							invoke	hexit,edx,addr buff,2
 00000201  6A 02	   *	    push   +000000002h
 00000203  8D 45 F6	   *	    lea    eax, byte  ptr ss:[ebp]+0F6h
 00000206  50		   *	    push   eax
 00000207  52		   *	    push   edx
 00000208  E8 0000003B	   *	    call   hexit
							invoke	StdOut,addr buff
 0000020D  8D 45 F6	   *	    lea    eax, byte  ptr ss:[ebp]+0F6h
 00000210  50		   *	    push   eax
 00000211  E8 00000000 E   *	    call   StdOut
							invoke	StdOut,offset space
 00000216  68 00000000 R   *	    push   dword  ptr OFFSET FLAT:space
 0000021B  E8 00000000 E   *	    call   StdOut
 00000220  46						inc	esi
 00000221  47						inc	edi
						.endw
 00000222		   *@C0011:
 00000222  3B 75 10	   *	    cmp    esi, loc2
 00000225  74 05	   *	    je     @C0013
 00000227  83 FF 20	   *	    cmp    edi, len
 0000022A  75 D3	   *	    jne    @C0012
 0000022C		   *@C0013:
 0000022C  83 C3 20				add	ebx,len
						invoke	StdOut,offset crlf
 0000022F  68 00000002 R   *	    push   dword  ptr OFFSET FLAT:crlf
 00000234  E8 00000000 E   *	    call   StdOut
					.endw		
 00000239		   *@C000F:
 00000239  3B 75 10	   *	    cmp    esi, loc2
 0000023C  75 AB	   *	    jne    @C0010
					ret
 0000023E  5F		   *	    pop    edi
 0000023F  5E		   *	    pop    esi
 00000240  5A		   *	    pop    edx
 00000241  59		   *	    pop    ecx
 00000242  5B		   *	    pop    ebx
 00000243  58		   *	    pop    eax
 00000244  C9		   *	    leave  
 00000245  C2 000C	   *	    ret    0000Ch
 00000248			printbyte endp	
					

				;##########################################################
 00000248			hexit	proc uses eax ebx esi edi ecx num:dword,pntr:dword,count:dword
 00000248  55		   *	    push   ebp
 00000249  8B EC	   *	    mov    ebp, esp
 0000024B  50		   *	    push   eax
 0000024C  53		   *	    push   ebx
 0000024D  56		   *	    push   esi
 0000024E  57		   *	    push   edi
 0000024F  51		   *	    push   ecx
 00000250  8B 45 08			mov	eax,num
 00000253  33 DB			xor	ebx,ebx
 00000255  B3 10			mov	bl,10h
 00000257  33 F6			xor	esi,esi
 00000259  8B 4D 0C			mov	ecx,pntr
					.while	esi!=count
 0000025C  EB 06	   *	    jmp    @C0016
 0000025E		   *@C0017:
 0000025E  33 D2				xor	edx,edx
 00000260  F7 F3				div	ebx
 00000262  46					inc	esi
 00000263  52					push	edx
					.endw	
 00000264		   *@C0016:
 00000264  3B 75 10	   *	    cmp    esi, count
 00000267  75 F5	   *	    jne    @C0017
					
 00000269  33 FF			xor	edi,edi
					.while	esi!=0
 0000026B  EB 16	   *	    jmp    @C0019
 0000026D		   *@C001A:
 0000026D  5A					pop	edx
 0000026E  4E					dec	esi
						.if	dx>9
 0000026F  66| 83 FA 09	   *	    cmp    dx, 009h
 00000273  76 06	   *	    jbe    @C001B
 00000275  66| 83 C2 37					add	dx,37h
						.else
 00000279  EB 04	   *	    jmp    @C001D
 0000027B		   *@C001B:
 0000027B  66| 83 C2 30					add	dx,30h
						.endif
				;		mov	byte ptr [pntr+edi],dl	;imp this wont work, herre pntr is not treated as pointer
 0000027F		   *@C001D:
 0000027F  88 14 0F				mov	[ecx+edi],dl
 00000282  47					inc	edi
					.endw
 00000283		   *@C0019:
 00000283  0B F6	   *	    or	esi, esi
 00000285  75 E6	   *	    jne    @C001A
 00000287  C6 04 0F 00			mov	byte ptr [ecx+edi],0
					ret	
 0000028B  59		   *	    pop    ecx
 0000028C  5F		   *	    pop    edi
 0000028D  5E		   *	    pop    esi
 0000028E  5B		   *	    pop    ebx
 0000028F  58		   *	    pop    eax
 00000290  C9		   *	    leave  
 00000291  C2 000C	   *	    ret    0000Ch
 00000294			hexit	endp	
				end	start
				;##########################################################	

